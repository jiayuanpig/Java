# 保证缓存和数据库双写一致性



最经典的缓存+数据库读写的模式：cache aside pattern

1、Cache Aside Pattern

- 读的时候，先读缓存，缓存没有的话就读数据库，然后取出数据放入缓存。
- 更新的时候先删除缓存，后更新数据库。

2、为什么先删除缓存而不是更新缓存？

这里选择删除缓存，因为如果涉及数据库的频繁改动，如果采用更新缓存的方式，当缓存涉及到大量的复杂查询或者不常用的查询语句，那就会因频繁更新缓存而占用资源。因此采用删除缓存的方式，当需要读取数据时再重新加载缓存。



业务场景：

实时性要求较高的数据缓存，例如库存服务

1、最初级的缓存不一致问题以及解决方案

问题：先修改数据库，后删除缓存。如果缓存删除失败，会导致数据库中是新数据，缓存是旧数据。

解决思路：先删除缓存后更新数据库，如果删除缓存成功而更新数据库失败，数据库是旧数据，缓存为空，那么数据不会不一致，因为读的时候因为没有缓存会读取数据库中的旧数据，然后更新到缓存中【至少保证数据库和缓存一致性】。如果删除缓存失败，可以再次执行，直到操作成功。

2、较为复杂的数据不一致问题分析

问题：数据发生了变更，先删除了缓存，然后修改数据库，此时还未修改。一个请求过来，发现没有缓存，就会去查询数据库，查到了修改前的旧数据，放到缓存中。此时，原程序完成了数据库的修改。此时，数据库和缓存不一致。

3、为什么上亿流量高并发会发生缓存和数据库不一致的问题？

只有在一个数据在并发环境进行读写，才会发生这种问题。如果并发量很低，特别是读并发很低，访问量就一万次，就会很少发生以上问题。当每秒访问量达到上万次，就容易出现数据库+缓存不一致问题。

4、解决办法：数据库和缓存进行异步串行化

对商品id进行hash取值，再加上对内存队列的数量进行取模，就可以将某一个商品路由到某一个**内存队列**中。使用内存队列，使得对同一数据的读写操作必须排队执行，就不会造成不一致场景。

如果等待队列时间过长，可以直接让库存服务调用一个线程去完成对应操作。

5、高并发场景下，该解决方案应该注意的问题？

- 读请求长时间阻塞：一般来讲，数据中的写操作频率是很低的。一般读请求是采用读缓存的方式完成，所以执行速度较快，很少出现队列积压现象。但是当读请求和更新请求发生冲突，当更新操作先入队列，就会发生后面的读请求进入等待，但是我们已经做了映射去重处理，在完成更新操作后，后面的读请求就可以读取缓存。【当写操作还是很多】，需要对实际业务进行模拟预测，如果发生堵塞就需要增加服务器进行处理。
- 读请求并发量过高：提前做好压力测试，评估服务器性能是否满足要求
- 多服务实例部署的请求路由：如果一个服务部署了多个实例，需要保证执行更新数据库和删除缓存的请求，都通过nginx服务器路由到相同的服务实例上。（意思就是对同一个商品的更新操作对应到固定的一个服务器中，该功能交给路由处理来保证实现）
- 热点商品的路由问题，导致请求倾斜：某一个商品的读写要求很高，导致很多请求都到一台机器的队列中，可能会造成机器压力过大。



