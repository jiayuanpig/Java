# 数据库优化

参考：https://www.cnblogs.com/sharpest/p/10390035.html

**需求分析：**性能优化是通过某些有效的方法来提高MySQL的运行速度，减少占用的磁盘空间。性能优化包含很多方面，例如优化查询速度，优化更新速度和优化MySQL服务器等。这里从四个方面进行优化：

- 设计：存储引擎，字段类型，范式与逆范式

- 功能：索引，缓存，分区分表。

- 架构：主从复制，读写分离，负载均衡。

- SQL语句优化：需要经过测试和经验总结对sql进行优化。

**统计参数**：数据库管理人员可以使用SHOW STATUS语句来查询MySQL数据库的性能。语法：SHOW STATUE LIKE ‘value’；其中value参数是常用的几个统计参数。

- Connections：连接MySQL服务器的次数
- Uptime：MySQL服务器的上线时间；
- Slow_queries：慢查询的次数；
- Com_select：查询操作的次数；
- Com_insert：插入操作的次数；
- Com_delete：删除操作的次数；
- Com_update：更新操作的次数；



## 设计优化

### 数据库引擎

**根据数据的特性选择对应的数据库引擎**

InnoDB支持事务和外键，保证数据完整性，擅长并发性处理，擅长更新，删除；

MyISAM支持大文件存储，高速查询及插入，支持全文索引；

Memory将数据存入内存中；



### 表的设计

**字符集**校对规则utf8_general_ci表示校对时不区分大小写，相对的cs表示区分大小写。还有一个bin结尾的是字节比较。而general是地区名，这里是通用，utf8表示编码。如果是gbk，可以使用gbk_chinese_ci，如果是utf8则用utf8_general。

**字段类型**应该要满足需求，尽量要满足以下需求：尽可能小（占用存储空间少）、尽可能定长（占用存储空间固定）、尽可能使用整数。

**将字段很多的表分解成多个表**

有些表在设计时设置了很多的字段。但是这个表中的有些字段的使用频率很低。当这个表的数据量很大时，查询数据的速度就会很慢。对于这种字段特别多的并且有字段的使用频率不高的表，就可以将其分解成多个表。

**增加中间表**

有时需要经常查询某两个表中的几个字段。如果经常进行联表查询，就会降低MySQL数据库的查询速度。对于这种情况可以建立中间表来提高查询速度。

先分析经常需要同时查询那几个表中的那些字段。然后将这些字段建立一个中间表，并将原来那几个表的数据插入到中间表中，之后就可以使用中间表来进行查询和统计了。

**逆范式-增加冗余字段**

是指打破范式，通过增加冗余或重复的数据来提高数据库的性能。设计数据库表时尽量让表达到三范式。但是，有时为了提高查询速度，可以有意识的在表中增加冗余字段。表的规范程度越高，表与表之间的关系就越多，查询时可能经常需要在多个表之间进行连接查询，而进行连接查询会降低查询速度。比如，学生的信息存储在student表中，院系的信息存储在department表中，通过student表中的dept_id字段与department表建立关联关系。如果要查询一个学生所在系的名称，必须从student表中拿到dept_id字段，然后根据这个编号去department表中查找系的名称。如果需要经常需要进行这个操作的话，连接查询会浪费很多时间。因此可以在student表中增加一个冗余字段dept_name，这样就不用每次都进行连接查询了。其实就是一切以业务为主。

**分析表，检查表，和优化表**

分析表的主要作用是分析关键字的分布。检查表的作用是检查表是否存在错误。优化表主要作用是消除删除或者更新造成的空间浪费。

分析表  ANALYZE TABLE 表名； 使用ANALYZE TABLE分析表的过程中，数据库系统会对表加一个只读锁。在分析表的过程中，只能读取表的内容，不能插入和更新表的内容。ANALYZE TABLE 语句能够分析InnoDB和MyISAM类型的表。

检查表使用CHECK TABLE语句。在执行过程中也会给表加上只读锁。

优化表使用OPTIMIZE TABLE语句。只能优化表中的VARCHAR,BLOB,TEXT类型的字段。OPTIMIZE TABLE语句可以消除删除和更新造成的磁盘碎片，从而减少空间浪费。因为如果一个表使用了TEXT或者BLOB这样的数据类型，那么更新，删除等操作就会造成磁盘空间的浪费。因为，更新和删除操作以后，以前分配的磁盘空间不会自动回收。使用OPTIMIZE TABLE语句可以将这些磁盘碎片整理出来，以便再利用。

### 优化MySQL服务器

硬件上的优化：增加内存和提高磁盘读写速度，都可以提高MySQL数据库的查询，更新的速度。另一种提高MySQL性能的方式是使用多块磁盘来存储数据。因为可以从多块磁盘上并行读取数据，这样可以提高读取数据的速度。

MySQL参数的优化：内存中会为MySQL保留部分的缓冲区。这些缓冲区可以提高MySQL的速度。缓冲区的大小都是在MySQL的配置文件中进行设置的。

> 下面对几个重要的参数进行详细介绍：
>
> - key_buffer_size：表示索引缓存的大小。这个值越大，使用索引进行查询的速度就越快
> - table_cache：表示同时打开的表的个数。这个值越大，能同时打开的表的个数就越多。这个值不是越大越好，因为同时打开的表过多会影响操作系统的性能。
> - query_cache_size：表示查询缓冲区的大小。使用查询缓存区可以提高查询的速度。这个方式只使用与修改操作少且经常执行相同的查询操作的情况；默认值是0.
> - Query_cache_type：表示查询缓存区的开启状态。0表示关闭，1表示开启。
> - Max_connections：表示数据库的最大连接数。这个连接数不是越大越好，因为连接会浪费内存的资源。
> - Sort_buffer_size：排序缓存区的大小，这个值越大，排序就越快。
> - Innodb_buffer_pool_size：表示InnoDB类型的表和索引的最大缓存。这个值越大，查询的速度就会越快。这个值太大了就会影响操作系统的性能。

合理配置这些参数可以提高MySQL数据库的性能。配置完参数后，需要重启MySQL服务才会生效。



## 功能

### 添加索引

主键索引，唯一索引，普通索引，全文索引、复合索引



### 使用缓存

查询缓存存在判断是严格依赖于select语句本身的：严格保证SQL一致。如果查询时包含动态数据，则不能被缓存。



### 分区分表

日常开发中我们经常会遇到大表的情况，所谓的大表是指存储了百万级乃至千万级条记录的表。这样的表过于庞大，导致数据库在查询和插入的时候耗时太长，性能低下，如果涉及联合查询的情况，性能会更加糟糕。分表和表分区的目的就是减少数据库的负担，提高数据库的效率，通常点来讲就是提高表的增删改查效率。

**分区**：是将数据分段划分在多个位置存放，可以是同一块磁盘也可以在不同的机器。分区后，表面上还是一张表，但数据散列到多个位置了。app读写的时候操作的还是大表名字，db自动去组织分区的数据。

**分表**：分表包括水平分表和垂直分表。水平分表表示某个表都放几行数据；垂直分表表示常用的几列放一个表，剩余几列作为附表存储



## 架构

### 主从复制

Mysql服务器内部支持复制功能，仅仅需要通过配置完成下面的拓扑结构。一主多从典型结果：主服务器负责写数据。从服务器负责读数据。复制功能mysql会自带。



### 读写分离、负载均衡

php不再操作MYSQL数据库服务器，而是去操作读写分离、负载均衡服务器，只要服务器安装了mysql proxy或Ameoba软件就可以实现读写分离和负载均衡，读写分离是指该服务器会判断客户端的操作是读还是写，从而选择操作mysql主服务器还是从服务器。负载均衡算法是指，客户端读操作时，该服务器会根据取余算法去选择一台从服务器。





## Sql优化

### 优化查询

很多查询中需要使用子查询。子查询可以使查询语句很灵活，但子查询的执行效率不高。MySQL需要为内层查询语句的查询结果建立一个临时表。然后外层查询语句在临时表中查询记录。查询完毕后，MySQL需要撤销这些临时表。所以在MySQL中可以**使用连接查询来代替子查询**。连接查询不需要建立临时表，其速度比子查询要快。

 **少用（不用）多表操作**（子查询，联合查询），而是将复杂的SQL拆分多次执行。如果查询很原子（很小），会增加查询缓存的利用率。

### 优化插入记录的速度

插入记录时，索引和唯一性校验都会影响到插入记录的速度。而且，一次插入多条记录和多次插入一条记录所消耗的时间是不一样的。根据这些情况，分别进行不同的优化。

禁用索引：插入记录时，MySQL会根据表的索引对插入的记录进行排序。如果插入大量数据时，这些排序会降低插入的速度。为了解决这种情况，在插入记录之前先禁用索引。等插入之后再启用索引。对于新创建的表，可以先不创建索引，等记录都导入以后再创建索引。这样可以提高导入数据的速度。

​    ALTER TABLE 表名 DISABLE KEYS；

​    ALTER TABLE 表名 ENABLE KEYS；

优化INSERT语句：当大量插入数据时，建议使用一个INSERT语句插入多条记录，而不是使用多次INSERT语句。这样可以减少与数据库之间的连接等操作。





# 缓存和数据库如何同步

**一般来讲，读数据是在缓存中读取，写数据需要直接操作数据库。**



## 读取缓存

首先，缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9EbWliaWFGaWFBSTRCMXFpYjJ3QU5YQVRTZ2FpYUo5dWh5WmtYRjVpYkp1Y3N5Nm81R2poN2R6aEZUdGVudDZHZDhHdm9KMThpYVFhVHZvMkdYNEZkOTZKUk9WS0EvNjQw?x-oss-process=image/format,png" alt="读取缓存步骤" style="zoom:67%;" />

## 更新缓存

但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。

先做一个说明，从理论上来说，**给缓存设置过期时间**，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。



### 是更新缓存还是删除缓存？

这里选择删除缓存，因为如果涉及数据库的频繁改动，如果采用更新缓存的方式，当缓存涉及到大量的复杂查询或者不常用的查询语句，那就会因频繁更新缓存而占用资源。因此采用删除缓存的方式，当需要读取数据时再重新加载缓存。



### 是先更新数据库还是先删除缓存？

**策略一：先删除缓存，后更新数据库**

同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:
（1）请求A进行写操作，删除缓存
（2）请求B查询发现缓存不存在
（3）请求B去数据库查询得到旧值
（4）请求B将旧值写入缓存
（5）请求A将新值写入数据库

上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。

如何解决这个问题？

**采用延时双删策略**

（1）先淘汰缓存
（2）再写数据库（这两步和原来一样）
（3）休眠一定时间，再次淘汰缓存

时间的长短需要自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。

**如果你用了mysql的读写分离架构怎么办？**
ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。
（1）请求A进行写操作，删除缓存
（2）请求A将数据写入数据库了，
（3）请求B查询缓存发现，缓存没有值
（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值
（5）请求B将旧值写入缓存
（6）数据库完成主从同步，从库变为新值 

上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。**采用这种同步淘汰策略，吞吐量降低怎么办？**
ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。

**第二次删除,如果删除失败怎么办？**
这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：
（1）请求A进行写操作，删除缓存
（2）请求B查询发现缓存不存在
（3）请求B去数据库查询得到旧值
（4）请求B将旧值写入缓存
（5）请求A将新值写入数据库
（6）请求A试图去删除请求B写入对缓存值，结果失败了。

ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。

**如何解决呢？**具体解决方案，看下面一种策略的解析。



**策略二：先更新数据库，后删除缓存**

首先，先说一下。老外提出了一个缓存更新套路，名为《Cache-Aside pattern》。其中就指出

- 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。

- 命中：应用程序从cache中取数据，取到后返回。

- 更新：先把数据存到数据库中，成功后，再让缓存失效。

**这种情况不存在并发问题么？**
不会的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生
（1）缓存刚好失效
（2）请求A查询数据库，得一个旧值
（3）请求B将新值写入数据库
（4）请求B删除缓存
（5）请求A将查到的旧值写入缓存 
ok，如果发生上述情况，确实是会发生脏数据。
**然而，发生这种情况的概率又有多少呢？**
发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。
假设，有人非要抬杠，有强迫症，一定要解决怎么办？
**如何解决上述并发问题？**
首先，给缓存设有效时间是一种方案。其次，采用异步延时删除策略，保证读请求完成以后，再进行删除操作。
**如何解决第二次缓存删除失败的问题？**
提供一个保障的重试机制即可，这里给出两套方案。
方案一：


![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9EbWliaWFGaWFBSTRCMXFpYjJ3QU5YQVRTZ2FpYUo5dWh5WmtYeUVmRk44MDZVMFpqYmFDSmp1UUNoUHJBaWFCWTY0QTZHQmljY3FzY0pJVWliQlVGRUlpYkpzRWljcEEvNjQw?x-oss-process=image/format,png)
流程如下所示
（1）更新数据库数据；
（2）缓存因为种种问题删除失败
（3）将需要删除的key发送至消息队列
（4）自己消费消息，获得需要删除的key
（5）继续重试删除操作，直到成功

然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。

方案二：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9EbWliaWFGaWFBSTRCMXFpYjJ3QU5YQVRTZ2FpYUo5dWh5WmtYaWFrTExUcGVlY24xZnRTZ1pSVlBpYllpYldyWkpVYzhqUk9iWE1TRmRaZ0Nwa0FYOXUzbnNVRWlhdy82NDA?x-oss-process=image/format,png)
流程如下图所示：
（1）更新数据库数据
（2）数据库会将操作信息写入binlog日志当中
（3）订阅程序提取出所需要的数据以及key
（4）另起一段非业务代码，获得该信息
（5）尝试删除缓存操作，发现删除失败
（6）将这些信息发送至消息队列
（7）重新从消息队列中获得该数据，重试操作。

备注说明：上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。

 





# 分库分表深入？？？

**什么时候分库分表？**

解决数据量、存储效率、日增量



效果：

提高查询数据效率

缓解数据库压力

提升存储容量



**分库分表有哪些类型？**

分库：不同库，表名相同



水平分表：表结构一致，表的具体数据会有区别

​	【根据数据特点划分表】例如：当天表、月度表、年表

​	【简单取模分表】根据某一字段取模分区或其他规则进行分区，方便查询（对应逻辑表-真实表）

​	【广播表】几个数据完全相同的表，分担并发查询的压力

​	

垂直分表









**分库分表带来的问题和解决方案？**

问题：

跨库的关联查询

创建全局表

数据同步问题

代码冗余

分布式事务控制



范围查询





采用自定义注解和多数据源的方式进行查询

编码层（数据源）--框架层（Mybatis）--驱动层（sharding-jdbc）--代理层（mycat）--服务层









**sharding-jdbc：基于客户端的分库分表**

**mycat：基于服务器端的分库分表**

二者比较

工作层面





















































