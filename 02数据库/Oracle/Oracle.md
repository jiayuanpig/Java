# Oracle

## 第一章 oracle从入门到精通

1.1 oracle安装
oracle从实际的开发来讲，oracle11g是使用较多的，oracle的开发主要
分为两类：
.数据库管理类：DBA
.数据库的编程：SQL编程 PL/SQL（子程序，触发器，面向对象，游标）

oracle下载的文件有两个压缩包，对于这两个压缩包建议分别解压缩，
而后合并成一个再进行安装启动
但是在进行oracle安装前要注意一下问题：
1.如果你的电脑上有各种病毒防火墙，建议关闭
2.在安装前，保证你的系统是健康的

oracle只是一个数据库平台，里面可能存在多个数据库

在oracle数据库里面，有一个比较牛的专业：IBM AIX+RAC

在进行安装时选择“高级配置”，配置编码，同时需要定义样本数据

在配置数据库名称时，会存在一个sid的内容，这个指的是Service ID
，服务ID,它的主要作用是数据库的网络连接使用，一般情况下，建议数据
库名称与SID一致


在oracle数据库中默认提供若干个用户，每个用户有不同的权限，此处会
询问是否为每个用户创建各自的用户和密码

进入到检测阶段，出现问题可以忽略

在安装完后，会进行用户的权限控制
在此处需要配置四个用户的密码：现在所配置的密码是通用密码。
.超级管理员：sys/change_on_install
.普通管理员：system/manager
.普通用户：scott/tiger(是在选定了“样本方案数据库之后产生的”)
.大数据用户：sh/sh

1.2 oracle的服务
oracle在使用的过程中必须启动系统服务，并且在oracle安装完成后
会自动地配置如下几个服务项（在服
务中自己找）
因为oracle会占用大量的系统内存，所以对oracle数据库的服务建议
手动启动，在所有的服务中，有两个服务是尤为重要的服务
OracleOraDb11g_home1TNSListener：监听服务
客户端访问本机时使用

OracleServiceORCL：数据库的实例服务
在oracle平台上可以同时配置多个数据库，"Configration Assistant"这个工具
可以建议多个数据库，每一个数据库建立完成后都会按照"ServiceSID"这个服务


1.3 sqlplus的操作
1.格式化操作
数据库本身是由一系列的数据表组成，所谓的表，就是行与列的集合
查询emp表的全部内容：select * from emp
设置每行显示的数据长度：SET LINESIZE 300;
设置每页显示的行数：SET PAGESIZE 30;
这些格式化的操作只是针对于数据库直接操作进行的，而在实际开发中
都是通过程序读取，所以这种格式化没有太大的意义。

对列进行格式化：col 列名称 FOR A 长度数字c

2.调用记事本："ed hello"
在使用ed命令时，如果不设置文件后缀，则默认使用的是.sql文件
同时这个文件会保存在用户目录下，可以在打开的记事本中编写命令e
并保存。co
如果想要执行该文，则使用 @文件名
利用@指令也可以调用磁盘上的文件，如果这个文件的后缀是"*.sql"
则可以不写文件的后缀 @e:data

3.显示用户
在一个数据库中会有多个操作用户，如果想要确定当前用户是哪一位，则使用 show user 命令。

用户的切换：conn 用户名[密码][AS SYSDBA]
如果现在使用的是sys用户登录，这属于超级管理员，那么必须设置SYSDBA，
否则无法登陆

如果使用sqlplus时，不需要用户登录，则加一个 /nolog 的参数 sqlplus /nolog

4.调用本机程序
在sqlplus中充分考虑到用户可能使用的系统命令，所有提供一个HOST指令
可以在host指令之后调用本机的指令执行
HOST COPY e:\data.sql e:\hello.sql


1.4 认识SQL
SQL:结构化的查询语句
SQL语句本身也分为若干个子类：
1.DML (数据库操作语言) 数据的更新与查询
2.DDL (数据库定义语言) 数据库的定义语言
3.DCL (数据库控制语言) 数据库的权限控制


scott用户表
1.如果想要知道一个用户（模式）所有的数据表，那么可以使用如下语法完成
SELECT * FROM tab;

2.查看某张表具体的结构
DESC 表名

3.scott用户中存在的四张表：
部门表：dept
雇员表：emp
工资等级表：salgrade
工资表：bonus 表中没有任何数据

 

## 第二章 SQL基础查询

2.1 SQL简单查询（主要特征是操作数据列，并未操作数据行）
||表连接
SELECT empno||ename FROM emp
SELECT '姓名:'||ename||' 编号:'||empno FROM emp;

普通数字：可以直接编写（SELECT ename|| 1 FROM emp）
字符串: 使用单引号声明（SELECT ename||'hello' FROM emp）

DISTINCT关键字：主要的目的是为了消除重复的关键字


2.2 SQL限定查询 （对数据进行筛选 where）
【3.选出需要的数据列】 SELECT [DISTINCT] *|列[别名],列[别名]...
【1.确定数据来源】FROM 表名[别名]
【2.筛选数据行】[WHERE 限定条件]

关系运算：> = < >= <= !=(<>)
范围运算：BETWEEN...AND
空判断： IS NULL IS NOT NULL
IN 判断： IN ,NOT IN, exists()
模糊查询：like

以上限定符都只能够判断一次，如果现在有若干个限定符，那么就需要
若干个限定符的逻辑运算：AND,OR ,NOT
以上所给出的判断是SQL中的标准支持，其他数据库可能有自己的标准内容

1.=：除了在数字上使用外，还可以在字符串上使用
2.在oracle中：数据是区分大小写的
3.在oracle中的所有运算都不受数据类型的控制，除了数字，还可以使用字符串或者
日期进判断。字符串的意义不大，重点来看日期判断

4.某些数据列上是允许为null的，但是null不能使用关系运算判断，关系可以判断的是
数字和字符串，但是null既不是字符串,也不是数字0，所以在oracle中
只能通过IS NULL来判断是否为空

5.若NOT IN中出现null，则不会有任何数据返回

6.关于like的两种查询
1）如果使用LIKE查询时，未使用任何的关键字，表示查询全部
2）LIKE可以再任何数据类型上使用

 


6.29 星期六
2.3 排序查询 order by
【3.选出需要的数据列】 SELECT [DISTINCT] *|列[别名],列[别名]...
【1.确定数据来源】FROM 表名[别名]
【2.筛选数据行】[WHERE 限定条件]
【4.数据排序】[ORDER BY 排序字段 [asc|desc]]...

排序可以在任意数据类型上进行（默认升序排列）

字段的混合排序，所有的排序操作都是在where筛选之后进行的

 

## 第三章 单行函数

3.1 单行函数简介
根据函数的特点，单行函数可以分为以下几种
1.字符串函数
2.数值函数
3.日期函数
4.转换函数
单行语句可以在SQL语句的任意位置上出现


3.2 字符串函数
字符串函数可以针对于字符串数据进行处理，在oracle中对于此类函数定义
UPPER() LOWER() INITCAP() REPLACE() LENGTH() SUBSTR()
1.大小写转换函数
UPPER(列|字符串)

2.首字母大写（首字母大写，其余字母都是小写）
字符串 INITCAP(列|数据)
SELECT INITCAP(ename) FROM emp;

3.计算字符串的长度
数字 LENGTH(列|字符串数据)
SELECT ename,LENGTH(ename) FROM emp;

4.z字符串的替换函数
字符串 REPLACE(列|数据,要查找的内容，新的内容)
SELECT REPLACE(ename,UPPER('a'),'');
实际上利用REPLACE()可以取消掉字符串中的全部空格数据：
SELECT REPLACE('Hello World',' ','') FROM dual;

5.字符串的截取（下表从1开始）
语法1：字符串 SUBSTR(列|数据,开始点),从指定的开始点一直截取到结尾
语法2：字符串 SUBSTR(列|数据,开始点,结束点),截取指定范围的字符串
SUBSTR()索引可以支持负数
Oracle中字符串的索引都是从1开始，即使设置为0,也会自动变为1


3.3 数值函数
1.ROUND()
2.TRUNC()
3.MOD()

1.四舍五入函数
数字 ROUND(列|数字 [,保留小数位]) ，如果不设置保留小数位则表示不保留

2.截取小数
TRUNC(列|数字 [,保留小数位])

3.求模
MOD(列1|数字1,列2|数字2)


3.4 日期函数
日期函数主要是进行日期处理的，但是在日期处理过程中会存在一个关键性的问题
：如何获取当前时间。为此在Oracle中专门提供了一个伪列，这个列不存在于表中
但是可以进行查询，那么这个伪列就是SYSDATE
SELECT SYSDATE FROM dual;

实际上对于日期计算提供有以下三种计算模式：
日期+数字=日期（若干天之后的日期）
日期-数字=日期（若干天之前的日期）
日期-日期=天数（两个日期之间的天数）

1.计算两个日期间所经历的月数总和
数字 MONTHS_BETWEEN(日期1,日期2);

计算两个日期间的年限
MONTHS_BETWEEN(日期1,日期2)/12

2.增加若干月之后的日期
语法：日期 ADD_MONTHS(日期,月数);

3.计算指定日期所在月的最后一天
日期 LAST_DAY(日期);


3.5 转换函数（重点）
所谓的转换函数就是实现字符串与日期，数字之间的转换。转换函数一共有三种
TO_CHAR()

1.字符串 TO_CHAR(日期|数字|列,转化格式)
对于日期的转换格式而言主要有两类格式：
|-日期转为字符串：年（yyyy）,月（mm）,日（dd）,时（hh,hh24）,分（mi），秒（ss）
|-数字转化为字符串：任意一位数字9 货币L

（一定要记住：这样的转换操作只是给我们提供了一个思想：日期要想转变格式
，最终需要转换为字符串，但是这样会破坏数据的一致性）

好处：可以拆分出日期的年，月，日

2.转日期函数 TO_DATE();
如果说一个字符串按照"'日-月-年'"的方式编写，那么可以自动转化为日期类。
字符串转化为日期类型，这个可以依靠为TO_DATE();

TO_DATE(字符串,转换格式);


3.转数字函数
数字 TO_NUMBER(字符串);

 

3.5 通用函数（Oracle自己的特色）
在Oracle中提供有两个简单的数据处理函数：NVL() DECODE().并且随着版本的提升衍生出
许多子函数。
1.处理null null在进行任何数学计算后，结果都是为空，在实际的计算过程中
如果发现内容为空，则用0来替代
NVL(列|null,默认的替代值);

2.多数值判断
所谓的多数值判断，指的是根据不同的结果在输出的时候进行一个数据的转换
DECODE(列,匹配内容1，显示内容1，匹配内容2，显示内容2,未匹配内容的默认值);

 



## 第四章 多表查询

1.多表查询的意义以及基本问题
2.表的连接查询
3.SQL：1999语法标准对多表查询的支持
4.数据的集合操作

4.1 认识多表查询
实际上所谓的多表查询就是从多张数据表中取出数据并且显示的一种操作

多表连接虽然消除了显示的笛卡尔积，但是笛卡尔积一致存在着，是无法消除的
如果说表之间的数据量小还可以承受，如果数据量大，那么多表查询会带来严重的
性能问题

判断是程序慢，还是数据库数据量大：
程序算法慢（CPU占用率高）
数据库数据量大（内存占用率高）


4.3 表的连接
实际上对于两张数据表进行多表查询对于消除笛卡尔积来讲主要是依靠连接模式来处理的
数据库有两种连接模式：
1.内连接
2.外连接

4.4 SQL:1999语法定义
SELECT [DISTINCT] *|列[别名]，列[别名],...
FROM 表1[别名]
[CROSS JOIN 表2[别名]]
[NATURAL JOIN 表2[别名]]
[JOIN 表2[别名] ON(条件)|USING(关联字段)]
[LEFT|RIGHT|FULL OUTER JOIN 表2];

1.交叉连接：目的是差生笛卡尔积
[CROSS JOIN 表2[别名]]

2.自然连接（内连接）：利用关联字段自己进行笛卡尔积的消除
(只要字段名称相同 自己匹配)
[NATURAL JOIN 表2[别名]]

3.外连接
SELECT [DISTINCT] *|列[别名]，列[别名],...
FROM 表1[别名]
[LEFT|RIGHT|FULL OUTER JOIN 表2];

全外连接：将左表和右表全都显示


4.4 数据集合操作
数字集合：交集、并集、差集、补集
UNION: 并集（消除重复的数据）
UNION ALL: 和（将所有的数据加在一起）
INTERSECT: 交集
MINUS: 差集

可是在使用集合操作之中有一件非常重要的注意事项，由于集合的操作最终是需要将
若干个查询结果合并为一个查询结果，所以要求这若干个查询结果所返回的数据必须相同

 

## 第五章 分组统计查询

1.统计函数的使用
2.分组统计查询的实现
3.对分组数据的过滤

5.1 统计函数（也称为分组函数）
count()
实际上针对COUNT()函数有三种使用形式：
COUNT(*)：可以准确地返回表中的全部记录数
COUNT(字段)：统计不为null的所有数据量
COUNT(DISTINCT 字段)：消除重复数据之后的结果

 

7.2 星期二
5.2 分组统计查询
【4.选出需要的数据列】 SELECT [DISTINCT] *|列[别名],列[别名]...
【1.确定数据来源】FROM 表名[别名]
【2.筛选数据行】[WHERE 限定条件]
【3】[GROUP BY 分组字段,分组字段,分组字段...]
【5.数据排序】[ORDER BY 排序字段 [asc|desc]]...

实际上GROUP BY子句之所以使用麻烦，是因为分组的时候有一些约定条件
.如果查询不使用GROUP BY子句，那么SELECT语句中只允许出现统计函数，
其他任何字段不允许出现

.如果查询中使用了GROUP BY子句，那么SELECT子句中只允许出现
分组字段，统计函数，其他字段都不允许出现

.统计函数允许嵌套，但是嵌套之后的SELECT子句里面只允许出现嵌套函数
而不允许包括分组字段


5.3 多表查询与分组统计（重点）
对于GROUP BY子句而言实在WHERE 子句之后执行的，所以在使用时，可以进行限定查询，
也可以进行多表查询


5.4 having子句（group 分组上进行限定）
having 是在GROUP BY分组之后才进行的筛选，在HAVING里面可以直接使用统计函数

WHERE与HAVING的区别？
.WHERE子句是在GROUP BY分组之前进行筛选，并且不允许使用统计函数
.HAVING子句是在GROUP BY分组之后执行，可以使用统计函数


5.5 分组查询案例
范例：显示所有非销售人员的工作名称以及从事同一工作的雇员的月工资的总和，
并且从事同一工作的雇员的月工资的总和大于5000,且按照工资总和升序排列
SELECT job,SUM(sal) sum
FROM emp
WHERE job <>'SALEMAN'
GROUP BY job
HAVING SUM(sal)>5000
ORDER BY sum asc;

 

## 第六章 子查询

1.分析子查询的使用情况
2.子查询对于查询性能的帮助

所有可能出现测子查询都需要使用()声明。所谓的子查询实质上就属于我们的查询嵌套
而且从理论上来讲，查询的任意位置上都可以出现子查询，但是出现子查询
最多的位置：WHERE FROM.所以针对于子查询的出现给出几个个人的
使用方案。


6.1 在where子句中使用子查询
6.1.1 子查询返回单行单列

6.1.2 子查询返回单行多列

6.1.3 子查询返回多行单列
如果说子查询返回了多行单列的数据，那么实质上就告诉了用户一个数据的范围。
如果想要进行一个范围的判断，在WHERE子句里提供有主要的三个运算符：
IN ANY ALL

1)IN 操作，是指内容可以在指定的范围之中存在
多行单列就相当于给出了我们的查询范围

NOT IN：一定要保证子查询中没有空

2）ANY 操作
对于ANY的操作有三种子操作
a.= ANY （本质上与IN没有任何区别）

b.>ANY (比最小的内容要大)

c. < ANY (比最大的内容要小)


3）ALL操作
\>ALL (比最大的内容要大)

<ALL (比最小的内容要小)


4）exist()
如果现在子查询有数据返回（不管什么数据），就表示条件满足，就可以显示出数据，否则不显示

 

6.2 在HAVING子句中使用子查询

6.3 在SELECT语句中使用子查询

6.4 FROM子句中出现子查询
为了解释这种查询的作用，下面做一个简单的查询
范例：查询出每个部门的编号，名称，位置，部门人数，平均工资

SELECT d.deptno,d.name,d.loc,count(*),AVG(sal)
FROM emp e,dept d
WHERE e.deptno(+)=d.deptno
GROUP BY d.deptno,d.name,d.loc


SELECT d.deptno,d.dname,d.loc,temp.count,temp.avg
FROM dept d,(
SELECT deptno,COUNT(empno) count,AVG(sal) avg
FROM emp GROUP BY deptno) temp
WHERE d.deptno=temp.deptno
//此种解法构造出零时表 temp

这两种方式有什么区别：
为了更好的解决此类问题，现在将数据量扩大100倍，emp：1400条记录，dept:400条记录
多表查询后分组统计：
数据量：1400*400=640000

子查询分组统计后进行多表查询：
FROM子句的数据量：1400行记录，最多返回400行记录
与dept表进行多表查询：最多返回400*400=160000
总共做了161400次运算

=========================性能优化===========================
1.between...and... 的性能优于 >.... and <....
原因：between and只做了一次运算， >.... and <....做了两次运算

2.查询分组统计后进行多表查询 的性能要优于 多表查询后分组统计

============================================================

 

## 第八章 数据更新

1.数据的增加
2.数据的修改
3.数据的更新

8.1、数据增加
对于数据表肯定需要新数据的加入，对于数据增加的操作，可以适用于如下的语法完成
INSERT INTO 表名称 [(字段名称,字段名称...)] VALUE (数据，数据...)

但是对于数据的增加操作需要注意一点，关于数据的定义问题：
.字符串函数 :用单引号括住
.数值函数：直接编写
.日期：有三种方式可以选择
1.可以设置为当前日期SYSDATE
2.根据日期的保存结构编写字符串
3.可以利用TO_DATE() 将字符串转化为DATE型数据

3.2 数据修改
UPDATE 表名称 SET 字段=内容,字段=内容,...[WHERE 更新条件]


3.3 数据删除
删除数据就是指所有的数据不再需要，对于删除语法
DELETE FROM [WHERE 删除条件]

 



## 第九章 事务处理

1.事务处理的作用
2.事务处理的命令

9.1 事务：保证事务完整性的一种手段。
事务具备ACID原则（保证你一个人更新数据的时候其他人不能更新）

在oracle之中，sqlplus是一个客户端。但是对于Oracle服务而言
每一个sqlplus的客户端都是独立的，都使用一个session描述


在事务的处理之中提供有两个核心的命令：
.提交事务：commit
.回滚事务：rollback


9.2 事务锁
按照之前的讲解，每一个session都进行自己的事务处理，那么如果说两个session
同时操作了同一条数据该如何了。

范例：第一个session更新7566雇员的信息
UPDATE emp SET sal=5000 WHERE empno=7566;
此时session并没有提交或回滚事务

范例：第二个session也更新7566雇员的信息
UPDATE emp SET comm=9000 WHERE empno=7566;
此时更新操作不能完成，因为两个不同的session更新了同一条数据，那么此时就会出现
一种情况：锁。即：在第一个session没有提交或回滚前，第二个session要一致等待着更新完成。
所以在事务的处理过程中有一个锁定的概念，即：在提交或者回滚之前，只能有一个session操作数据
这就是事务的隔离性

 



## 第十章 数据伪列

伪列：列本身不存在，但是却可以使用的列。Oracle提供有两个非常重要的伪列
：ROWNUM,ROWID

10.1 ROWNUM(核心)
如果在开发之中使用了ROWNUM，那么就表示会自动生成行号。
行号是根据查询结果动态计算出来的，所以每一个行号都不会与特定的记录捆绑。
在实际的开发过程中，ROWNUM可以做两件事情，
.取得第一行数据
.取得前n行数据（重要）

解释：为什么NOT IN里面不能够有null
NOT IN(null) ，如果某一列的内容没有null,那么就表示查询全部，但是NOT IN 本身
的作用是进行数据的部分筛选，由于自身的数据错误导致查询全部，那么就是灾难了


范例：取得6-10行数据
错误的做法：
SELECT ROWNUM,empno,ename FROM emp WHERE ROWNUM BETWEEN 6 AND 10;
在数据表的查询过程之中，ROWNUM不能定义范围，所以此时要想正确实现需要的功能
必须通过子查询完成。子查询中，首先查询前10行记录，而后查询后5 行记录


分页sql语句
currentPage:当前页号
lineSzie:每页记录的条数

SELECT *
FROM (
SELECT ROWNUM rn,列,...FROM 表名称
WHERE ROWNUM<=currentPage*lineSize)temp
WHERE temp.rn>(currentPage-1)*lineSize;


10.1 ROWID（理解）
所谓的ROEID指的是针对于每行数据提供的物理地址

以"AAAR3qAAEAAAACHAAA"这个数据为例，介绍ROWID的组成
.数据对象编号：AAAR3q
.数据文件编号：AAE
.数据保存的块号：AAAACH
.数据保存的行号：AAA

面试题：表中有很多完全重复的数据，要求将重复的数据删除掉（只剩最早一个）

 



## 第十一章 表的创建与管理

1.常见的数据类型
2.表的创建操作
3.表的删除操作
4.表的修改操作

11.1 常用数据类型（重点）
1）字符串：使用VARCHAR2描述 （其他数据库使用VARCHAR）

2）数字：Oracle之中使用NUMBER来描述数字，如果描述小数使用NUMBER(m,n),
其中m-n为整数位，n为小数位，但是数据库也考虑了我们程序开发人员的习惯
整数：INT
小数：FLOAT
3）日期：使用DATE是最常见的做法，但是在Oracle里面DATE包含有日期时间，可是其他的数据库
里面，DATE可能只是日期，DATETIME才表示日期时间

4）大文本数据：使用CLOB描述，最多可以保存4G文字

5）大对象数据：使用BLOB描述，保存图片，音乐，电影文字最多可以保存4G


11.2 创建数据表
CREATE TABLE 表名称(
列名称 类型 [DEFAULT 默认值],
列名称 类型 [DEFAULT 默认值],
列名称 类型 [DEFAULT 默认值],
.
.
列名称 类型 [DEFAULT 默认值]
);

 

11.3 表的复制
严格的来说复制表不是复制的操作，而是将一个子查询的返回结果变为一张表的形式
保存，复制表的操作可以使用如下的语法完成
CREATE TABLE 表名称 AS 子查询

只复制表结构，不复制表内容：只需要添加一个绝对不可能满足的条件即可

 

11.4 表的截断操作
事务是保证数据完整性的一种手段：但是在使用事务的处理过程中需要注意一点：
在用户进行数据更新后还未进行事务提交中，如果发生了DDL语言，那么所有的事务将自动
提交

TURNCATE TABLE 表名称 ：删除表时进行资源释放


11.5 表的重命名
RENAME 表名称1 TO 表名称2；

DDL：数据对象定义语言，主要的功能是创建对象，但是问题是这些对象
是谁记录着？
当用户进行对象操作的时候，Oracle中有一个数据字典，记录表的增加，删除信息
但是这个数据字典是Oracle自己维护的，用户不能够直接操作数据字典的CRUD

数据字典用户常用主要分为三类：
USER_*:用户的数据字典信息
DBA_*: 管理员的数据字典
ALL_* : 所有人可以看的数据字典
在之前使用过这样的语句：
SELECT * FROM tab;
严格来讲此时可以使用数据字典完成
SELECT * FROM user_tables;
user_tables这个数据字典记录了保存数据的存储情况，以及占用资源的情况


7.6 星期6
11.6 表的删除（重点）
删除数据表属于数据库对象的操作：
DROP TABLE 表名称

在最早的时候，如果进行了删除语句，数据表就会进行直接删除，但是在Oracle 10g以后
对于删除操作，出现了一次挽救的机会。类似于window的回收站，
如果没有其他的说明，会将删除的表保存在回收站之中，如果用户删除出现了问题
可以进行恢复，或者是彻底删除。称之为闪回技术（Flash Back）

在任何数据库里没有批量删除数据表的操作

 

11.7 闪回技术
FlashBack给与用户最直接的支持是给了用户后悔机会，但是用户现在想要去操作这个回收站，
那么对于用户而言应具备查看，恢复，清空，彻底删除几项操作。

1）查看回收站
SHOW RECYCLEBIN(古老命令，不支持了)
SELECT * FROM user_recycle_bin;

现在发现person表删除错误，于是想利用闪回技术恢复：
FLASHBACK TABLE person TO BEFORE DROP;

但是有的同学认为，这样删除太麻烦了，希望有想windows那样彻底删除的选项
，可以使用"PURGE"
彻底删除person表
DROP TABLE person PURGE;

删除回收站的表person：
PURGE TABLE person

清空回收站：
PURGE RECYCLEBIN;

 

11.8 修改表的结构
1.修改已有列：
ALTER TABLE 表名 MODIFY(列名 数据类型(长度) DEFAULT'默认值');

2.为表增加列
如果发现表中列的功能不足，那么就需要为其增加新的功能列
ALTER TABLE 表名称 ADD(列名 数据类型(长度) [DEFAULT 默认值]);

3.删除表中的列
任何情况下，删除这种操作都是及其危险的。
ALTER TABLE DROP COLUMN 列名称;

 

## 第12章 约束的创建与管理（最为重要）

1.5种约束的使用
2.约束的管理

数据表本身只支持数据的存储操作，但是在数据库上为了保证数据的完整性，
即：需要在满足若干条件之后才可以进行操作，例如用户信息不可以重复。

本质上来说数据库中的约束一种有6种：
数据类型，非空约束，唯一约束，主键约束，检查约束，外键约束
但是约束是一把双刃剑，约束确实是可以保证数据合法后才可以进行保存
但是在一个数据库里面设置了过多的约束，那么数据更新的操作一定会慢
所以在开发之中，一些更新的操作还是强烈建议交给程序完成。

1.非空约束(NOT NULL NK)
所谓的非空约束指的是表中的某一个字段的内容不允许为空，如果要是用
非空约束，只需要在每个列的后面使用 NOT NULL 声明即可


2.唯一约束（UNIQUE UK）
唯一约束的特点是在某一个列上的内容不允许重复

创建数据表
CREATE TABLE member(
mid NUMBER,
name VARCHAR2(20) NOT NULL,
email VARCHAR2(20)
CONSTRAINT uk_email UNIQUE(email)
)
此时如果违反了唯一主键原则，则提示为
ORA-00001:违反唯一约束条件（SCOTT.UK_ENAME）


3.主键约束（PRIMARY KEY,PK）
主键约束=非空约束+唯一约束

Oracle是允许定义多个列为主键，这样的操作往往称为复合主键
如果是符合主键，那么当着若干个主键完全重复时，才违反唯一
主键原则


4.检查约束
检查约束是指在数据列上设置一些过滤条件，当过滤条件满足时
才可以进行保存


5.外键约束
外键约束主要是在父子表关系中体现的一种约束操作。
CREATE TABLE book(
bid NUMBER,
title VARCHAR(20),
mid NUMBER,
CONSTRAINT fk_mid FOREIGN KEY(mid) REFERENCE member(mid)
)
所谓外键就相当于字表中某一个字段的内容由父表来决定其使用范围
对于外键而言最为麻烦的在于一堆限制

限制1：再删除父表之前需要删除掉他所对应的的全部字表后才可以删除
但是有些时候，一些奇葩的设计者，将A表作为B表的父亲，B表也作为A表的父亲
那么A，B两表都不允许被删除。此时在Oracle中专门提供了一个强制删除父表的操作
，删除之后不关心字表
DROP TABLE member CASCADE CONSTRAINT
此时强行删除member表，字表不会受影响


限制2：如果要作为字表外键的父表列，那么这个列必须设置为唯一约束或主键


限制3：如果现在柱表中中的某一行数据有对应的字表数据，那么必须删除字表中的全部数据
如果说现在不想受到子记录的困扰，那么就可以使用级联

级联删除：
所谓级联删除是指在父表数据已经被删除的情况下，自动删除其对应字表的数据
在定义外键的时候定义：ON DELETE CASCADE 即可

级联更新：
如果说现在删除父表数据的时候，那么对应的字表数据的外键列就设置为空
使用ON DELETE SET NULL 设置


6.修改约束（了解）
如果说表结构的修改还在容忍的范畴之内，那么约束的修稿就对是100%禁止的
所有的约束一定要在表创建的时候就设置完整


实际上约束可以进行后期的添加以及后期的删除操作。但是如果想要进行这样的
维护，那么必须保证有约束名称

1.增加约束
ALTER TABLE 表名称 ADD CONSTRAINT 约束名称 约束类型（字段）选项....
范例:为member表增加主键约束
ALTER TABLE ADD CONTRAINT pk_mid PRIMARY_KEY(mid)

利用以上语法可以实现4种约束的增加：主键，唯一，检查，外键
但是不包含非空，如果想要为字段增加非空约束，那么只能依靠修改表结构完成
ALTER TABLE mem(name VARCHAR2(20) NOT NULL);


2.删除约束
ALTER TABLE 表名称 DROP CONSTRANINT 约束名称

所以综合来说，不要修改表结构，且约束和表一起创建

 

7.8 星期一

## 第14章 常用数据库对象

14.1.序列的使用
在许多数据库中都存在一种数据类型---自动增长列，它能够创建流水号。
但是遗憾的是，在Oracle12C之前并没有提供这样自动的增长列，但是从12c开始
出现了自动增长，如果想要实现自动增长列，那么就可以使用序列的方式完成
如果想要使用序列，则可以采用如下的方式完成创建

语法：
CREATE SEQUENCE 序列名称
[MAXVALUE 最大值|NOMAXVALUE]
[MINVALUE 最小值|NOMINVALUE]
[INCREMENTBY 步长][START WITH 开始值]
[CYCLE|NOCYCLE] 是不是循环序列
[CACHE 缓存个数|NOCACHE]
序列属于数据库对象的创建过程，属于DDL的分类范畴（数据定义语言），对于序列而言 ，
创建之后一定会在数据字典之中保存

范例：创建序列
CREATE SQUENCE myseq;

既然序列的对象信息会在数据字典之中保存，那么现在就可以查询序列的数据字典
范例：查询user_squence数据字典

当序列已经创建成功了，如果想要使用序列则可以使用如下两个伪列完成
nextval:取得序列下一个内容，每一次调用，序列的值都会增长
currval:表示取得序列的当前内容，每一次调用序列不会增长，如果想要使用此伪列，那么在使用之前
必须首先使用nextval()取得内容才可以。


7.9 星期二
14.2 定义特殊序列
如果想要在实际开发之中使用序列进行开发，那么必须手工在数据增加的时候进行处理，
而数据表的形式与之前没有任何区别
CREATE TABLE mytab(
id NUMBER,
name VARCHAR2(50),
CONSTRAINT pk_id PRIMARY KEY(id)
);
此时数据表与原始相比没有任何区别，但是最关键的部分是在数据增加的时候，（id是主键列），
可以利用序列来生成id的内容。

INSERT INTO mytab(id,name) VALUES(myseq.nextval,'HELLO');
以上的操作是序列在实际开发中使用最多的情况，但是从序列的创建语法来讲，并不是这么简单
下面需要针对序列做进一步的分析





## 第15章 视图的定义及使用（重要）

1.视图的定义语法
2.视图的使用限制

15.1 视图的创建及使用
利用视图可以实现复杂SQL语句的封装操作。从实际的开发来说，
一个优秀的数据库设计人员除了要给出合理的数据表结构之外，
还应该将所有可能用到的查询封装好视图，一并交给开发者

视图依然属于DDL的定义范畴，所以视图的创建需要使用如下语法完成：
CREATE[OR REPLACE] VIEW 视图名称 AS 子查询;

范例：创建视图
CREATE VIEW myview AS SELECT * FROM emp WHERE deptno=10;
提示：权限不足

在Oracle 10g及以前版本，scott是可以直接进行视图创建的，但是从
Oracle 10G R2版本开始如果想要在scott中创建视图，那么就需要单独
分配创建视图的权限

范例：为scott分配创建视图的权限
CONN sys/change_on_install AS SYSDBA;
GRANT CREATE VIEW TO scott;
CONN scott/tiger
权限分配完成后，则可以进行视图的创建操作。视图本身属于数据库对象，
所以要想查看视图的信息可以使用"user_views"数据字典完成。在这个视
图中，可以查询到具体的语法。
SELECT * FROM user_views;


视图可以像普通数据表那样直接进行查询。查询视图与之前使用SELECT查询
结果是完全相同的，所以视图就包装了SQL语句，而开发者可以通过视图查询
到所需要的数据

查询视图：
SELECT * FROM myview;


若视图的名称已经被占用了，那么理论上应该先删除，而后再创建。可是删除与
创建之间可能产生间隔。所以在实际之中，由于视图使用频率较高，直接与开发有
关，那么一般情况下不会选择删除后重新创建，而是选择进行视图的替换。利用新
的查询替换掉旧的查询。


15.2 视图的更新操作
实际上视图只是包含有查询语句的零时数据，并不是真实存在的，可是在默认情况
下，我们创建的视图是可以进行修改操作的。

1.对视图的创建条件进行更新
CREATE VIEW myview AS SELECT * FROM emp WHERE deptno=20 WITH CHECK OPTION;
此时使用了WITH CHECK OPTION子句可以保证视图的创建条件不被更新，如果更新了视图
的创建条件，那么会有提示信息：
ORA-01402:视图WITH CHECK OPTION where子句违规

2.对视图的其他字段进行更新（非视图的创建条件）
但是视图中不光有创建条件的字段，还可能会包含其他字段，可是在现在的操作中
可以修改视图中的其他内容
修改其他字段：
UPDATE myview SET sal=80000 WHERE empno=7369;
此时更新的操作成功，但是发现视图更新时改变的是数据表中的数据，那么这样的操作
同时也是不合理的。
所以在一般创建视图的时候，由于里面都属于映射的数据，那么本质上就不建议修改，
建议创建一个只读视图。使用WITH READ ONLY完成。这样就避免了通过视图的临时数据
来修改数据表的真实数据。


疑问：直接修改视图挺方便的，为什么非要使用只读视图？
以上的讲解只是分析问题，但是如果现在只是单表查询，那么封装为视图有个P用


总结：理论上从正规的开发项目来说，一个数据库之中应该包含很多个视图
但是在现实开发中，有些团队不使用视图。

 



## 第十七章 数据库备份

数据库的备份操作在所有项目的运营环境中都要涉及到


17.1 数据库的导入与导出
1.数据的导出
1）首先需要准备一个进行数据备份的目录，假如说现在将D:\backup
目录作为备份路径。

2）需要进入到backup目录中（以命令行的方式进入）
cd backup

3)输入exp指令，导出数据（在backup目录中）

1.数据的导入
1）进入到备份文件所在路径
2）输入imp指令

在实际的备份操作之中，这样的操作使不了。因为在其导出过程之中，必须
保证其他用户不更新数据。


17.2 数据库的冷备份
数据库的冷备份严格来说称为归档备份，指的是数据库要关闭服务，所有的事务都需要提交
从实际来说要进行数据的备份则需要备份如下内容：
1.控制文件:控制整个Oracle的实例，可以使用"v$controlfile"数据字典找到

2.重做日志文件："v$logfile"数据字典找到

3.数据文件：通过"v$datafile"数据字典找到

　 4.核心配置文件pfile:使用SHOW PARAMETER pfile找到

数据库的备份操作肯定要由管理员进行。

1.使用sys登录
CONN sys/change_on_install AS SYSDBA;

2.查找控制文件的信息
SELECT * FROM v$controlfile

3.查找重做日志信息
SELECT * FROM v$logfile;

4.找到所有数据文件信息
SELECT * FROM v$datafile;

\5. 找到pfile文件
SHOW PARAMETER pfile

6.记录好这些文件的路径

7.关闭Oracle服务
SHUTDOWN IMMEDIATE

8.重启服务
startup