# 整型上下限问题

以Java中的Byte为例，Byte一共1个字节，共八位，假设有一位作为符号位，可以表示的范围为-128~127。



**范围分析：**

一共八位：0000 0000，首位作为符号位，0代表正数，1代表负数

从正数看：0000 0001~0111 1111代表1~127（2^7-1）

从负数看：1000 0001~1111 1111代表-1~-127

此时，还有两个特殊数：0000 0000 和1000 0000

我们使用 0000 0000表示0，1000 0000表示-128



**原码、反码与补码：**

正数：原码和反码和补码都相同

负数：反码是原码**除符号位**按位取反，补码是原码的反码+1



**计算机内部计算：**

> 由于计算中的CPU只有加法器，没有减法器，所以在计算机采用原码做减法是会存在问题的

​	**对于1+1=2的问题**

​		转换为二进制：0000 0001 + 0000 0001 = 0000 0010结果为2

​	**对于1-1=0的问题会转换为1+（-1）=0，发生错误**

​		转换为二进制：0000 0001 + 1000 0001 = 1000 0010结果为-2，是不对的。

**那么，如何解决这个问题呢？**

> 这里引入补码来进行运算。
>
> 由于采用补码运算，则补码加法成为：[X+Y]补 = [X]补 + [Y]补同时，补码的减法变为：[X-Y]补 = [X]补 - [Y]补 = [X]补 + [-Y]补 补码的乘法变为：【X*Y】补=【X】补×【Y】补；**结果需要逆补码处理，先-1然后取反**

**以正数为例**：正数的补码和原码相同，同上。

​	1+1=2 转换为二进制：0000 0001 + 0000 0001 = 0000 0010再转为原码，结果为2

**以负数为例**：

​	1+（-1）= 0转换为：结果补 = 1补+（-1）补

​	转换为二进制：（0000 0001）补 + （1000 0001）补 = 0000 0001 + 1111 111 1 = 0000 0000，再转为原码结果为0

​	1 - 2 =  - 1

​	转换为二进制：（0000 0001）补 + （1000 0010）补 = 0000 0001 + 1111 111 0 = 1111 1111，再转为原码1000 0001，结果为-1

​	2 - 1 = 1

​	转换为二进制：（0000 0010）补 + （1000 0001）补 = 0000 0010 + 1111 111 1 = 0000 0001，再转为原码0000 0001，结果为1

​	2 - 4 =  - 2

​	转换为二进制：（0000 0010）补 + （1000 0100）补 = 0000 0010 + 1111 1100 = 1111 1110，再转为原码1000 0010，结果为-2



**【注意】0000 0000 和 1000 0000转为补码后，都变成 0000 0000；任何原码都不能转化成补码后是1000 0000的形式**

