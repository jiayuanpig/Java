# 线程

## 创建线程

### 方式1：继承Thread类

Java使用`java.lang.Thread`类代表**线程**，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来**创建**并**启动多线程**



步骤：

1. 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。
2. 创建Thread子类的实例，即创建了线程对象
3. 调用线程对象的start()方法来启动该线程



**测试类：**

~~~java
public class Demo01 {
	public static void main(String[] args) {
		//创建自定义线程对象
		MyThread mt = new MyThread("新的线程！");
		//开启新线程
		mt.start();
		//在主方法中执行for循环
		for (int i = 0; i < 10; i++) {
			System.out.println("main线程！"+i);
		}
	}
}
~~~

**自定义线程类：**

~~~java
public class MyThread extends Thread {
	//定义指定线程名称的构造方法
	public MyThread(String name) {
		//调用父类的String参数的构造方法，指定线程的名称
		super(name);
	}
	/**
	 * 重写run方法，完成该线程执行的逻辑
	 */
	@Override
	public void run() {
		for (int i = 0; i < 10; i++) {
			System.out.println(getName()+"：正在执行！"+i);
		}
	}
}
~~~



### 方式2：实现Runnable接口

采用```java.lang.Runnable``` 也是非常常见的一种，我们只需要重写```run```方法即可。



步骤如下：

1. 定义```Runnable```接口的实现类，并重写该接口的```run()```方法，该```run()```方法的方法体同样是该线程的线程执行体。
2. 创建```Runnable```实现类的实例，并以此实例作为```Thread```的```target```来创建```Thread```对象，该```Thread```对象才是真正的线程对象。
3. 调用线程对象的```start()```方法来启动线程。



代码如下：

  ```java
  public class MyRunnable implements Runnable{
      @Override
      public void run() {
          for (int i = 0; i < 20; i++) {
          System.out.println(Thread.currentThread().getName()+" "+i);
          }
      }
  }
  
     
  ```

  ```java
   public class Demo {
      public static void main(String[] args) {
          //创建自定义类对象 线程任务对象
          MyRunnable mr = new MyRunnable();
          //创建线程对象
          Thread t = new Thread(mr, "小强");
          t.start();
          for (int i = 0; i < 20; i++) {
              System.out.println("旺财 " + i);
          }
      }
  }
  ```

  

通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。

在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。

实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的```API```来控制线程的，熟悉Thread类的```API```是进行多线程编程的基础。

  ### 区别

  如果一个类继承Thread，则不适合资源共享。但是如果实现了```Runable```接口的话，则很容易的实现资源共享。
  总结：
  实现Runnable接口比继承Thread类所具有的优势：

  1. 适合多个相同的程序代码的线程去共享同一个资源。

  2. 可以避免```java```中的单继承的局限性。

  3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。

  4. 线程池只能放入实现```Runable```或Callable类线程，不能直接放入继承Thread的类。

     

## 线程同步
### 同步代码块

synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。
格式:

```java
synchronized(同步锁){
	需要同步操作的代码
}
```

### **同步锁**

对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.

1. 锁对象 可以是任意类型。
2. 多个线程对象 要使用同一把锁。
   注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着
   (BLOCKED)。

```java
public class Ticket implements Runnable{
    private int ticket = 100;
    Object lock = new Object();
    /*
     * 执行卖票操作
     */
    @Override
    public void run() {
        //每个窗口卖票的操作
        //窗口 永远开启
        while(true){
            synchronized (lock) {
                if(ticket>0){//有票 可以卖
                    //出票操作
                    //使用sleep模拟一下出票时间
                    try {
                        Thread.sleep(50);
                    }
                    catch (InterruptedException e) {
                        // TODO Auto‐generated catch block
                        e.printStackTrace();
                    }
                    //获取当前线程对象的名字
                    String name = Thread.currentThread().getName();
                    System.out.println(name+"正在卖:"+ticket‐‐);
                }
            }
        }
    }
}
```

### 同步方法

- **同步方法:**使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。

格式：
```java
public synchronized void method(){
	可能会产生线程安全问题的代码
}
```

```标记
同步锁是谁?
对于非static方法,同步锁就是this。
对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。
```



代码如下

```java
public class Ticket implements Runnable{
    private int ticket = 100;
    /*
     * 执行卖票操作
     */
    @Override
    public void run() {
    //每个窗口卖票的操作
    //窗口 永远开启
        while(true){
            sellTicket();
        }
    }
    /*
     * 锁对象 是 谁调用这个方法 就是谁
     * 隐含 锁对象 就是 this
     */
    public synchronized void sellTicket(){
        if(ticket>0){//有票 可以卖
    //出票操作
    //使用sleep模拟一下出票时间
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
			// TODO Auto‐generated catch block
            }
			//获取当前线程对象的名字
            String name = Thread.currentThread().getName();
            System.out.println(name+"正在卖:"+ticket‐‐);
        }
    }
}
```

###  Lock锁

```java.util.concurrent.locks.Lock``` 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。
Lock锁也称同步锁，加锁与释放锁方法化了，如下：

- ```public void lock() :```加同步锁。
- ```public void unlock() :```释放同步锁。

```java
public class Ticket implements Runnable {
    private int ticket = 100;
    Lock lock = new ReentrantLock();

    /*
     * 执行卖票操作
     */
    @Override
    public void run() {
        //每个窗口卖票的操作
        //窗口 永远开启
        while (true) {
            lock.lock();
            if (ticket > 0) {//有票 可以卖
            //出票操作
            //使用sleep模拟一下出票时间
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
				// TODO Auto‐generated catch block
                    e.printStackTrace();
                }
				//获取当前线程对象的名字
                String name = Thread.currentThread().getName();
                System.out.println(name + "正在卖:" + ticket‐‐);
            }
            lock.unlock();
        }
    }
}
```



## 线程池

Java里面线程池的顶级接口是```java.util.concurrent.Executor``` ，但是严格意义上讲Executor 并不是一个线程
池，而只是一个执行线程的工具。真正的线程池接口是```java.util.concurrent.ExecutorService``` 。
要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优
的，因此在```java.util.concurrent.Executors ```线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。
Executors类中有个创建线程池的方法如下：
- ```public static ExecutorService newFixedThreadPool(int nThreads) ```：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)
获取到了一个线程池```ExecutorService``` 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：
- ```public Future<?> submit(Runnable task)``` :获取线程池中的某一个线程对象，并执行
Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。
使用线程池中线程对象的步骤：
1. 创建线程池对象。
2. 创建Runnable接口子类对象。(task)
3. 提交Runnable接口子类对象。(take task)
4. 关闭线程池(一般不做)。



**Runnable实现类：**

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("我要一个教练");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("教练来了： " + Thread.currentThread().getName());
        System.out.println("教我游泳,交完后，教练回到了游泳池");
    }
}
```

**线程池测试类**

```java
public class ThreadPoolDemo {
    public static void main(String[] args) {
        // 创建线程池对象
        ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象
		// 创建Runnable实例对象
        MyRunnable r = new MyRunnable();
        //自己创建线程对象的方式
        // Thread t = new Thread(r);
        // t.start(); ‐‐‐> 调用MyRunnable中的run()
        // 从线程池中获取线程对象,然后调用MyRunnable中的run()
        service.submit(r);
		// 再获取个线程对象，调用MyRunnable中的run()
        service.submit(r);
        service.submit(r);
        // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。
        // 将使用完的线程又归还到了线程池中
        // 关闭线程池
        //service.shutdown();
    }
}
```

