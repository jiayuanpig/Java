###  1、short s1 = 1; s1 = s1 + 1

> 对于short s1 = 1; s1 = s1 + 1; 由于s1+1 运算时会自动提升表达式的类型，所以结果是int 型，
> 再赋值给short 类型s1 时，编译器将报告需要强制转换类型的错误。
> 对于short s1 = 1; s1 += 1;由于+= 是java 语言规定的运算符，java 编译器会对它进行特殊处
> 理，因此可以正确编译。

### 2、"=="和equals 方法

> ==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存
> 储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作
> 符。
>
> equals 方法是用于比较两个独立对象的内容是否相同

### 3、Servlet 的生命周期？

> Servlet 被服务器实例化后，容器运行其init 方法，请求到达时运行其service 方法，service方法自动派遣运行与请求对应的doXXX 方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy 方法。
> 与cgi 的区别在于servlet 处于服务器进程中，它通过多线程方式运行其service 方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而**CGI 对每个请求都产生新的进程，服务完成后就销毁**，所以效率上低于servlet

### 4、StringBuffer 与StringBuilder 

> 因为StringBuilder sbuilder = ;是线程不安全的，运行效率高，如果一个字符串变量是在方法
> 里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。
> 如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用
> StringBuffer。

### 5、面向对象的特征有哪些方面？

> 封装：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类
> 中。
>
> 抽象：抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面
>
> 继承：在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承
>
> 多态：多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性

### 6、String s="a"+"b"+"c"+"d"？

> String s1 = "a";
> String s2 = s1 + "b";
> String s3 = "a" + "b";
> System.out.println(s2 == "ab");
> System.out.println(s3 == "ab");
> 第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac 编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。题目中的第一行代码被编译器在编译时优化后，相当于直接定义了个”abcd”的字符串，所以，上面的代码应该只创建了一个String 对象。写如下两行代码，
> String s = "a" + "b" + "c" + "d";
> System.out.println(s == "abcd");
> 最终打印的结果应该为true。

### 7、**类的加载顺序**。

> (1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)
>
> (2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )
>
> (3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )
>
> (4) 父类构造函数
>
> (5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )
>
> (6) 子类构造函数

### 8、常见注意事项

> 1、方法内定义的变量没有初始值，必须要进行初始化。 类中定义的变量可以不需要赋予初始值，默认初始值为0。
>
> 在接口中，属性默认public static final

### 9、Java垃圾回收机制

> 两个最基本的java回收算法：复制算法和标记清理算法
>
> 复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法
>
> 标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出
>
> 标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象
>
> 两个概念：新生代和年老代
>
> 新生代：初始对象，生命周期短的
>
> 永久代：长时间存在的对象
>
> 整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。
>
> P.S：**Serial New收集器是针对新生代的收集器，采用的是复制算法**
>
> **Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理**
>
> **Parallel** **Scavenge（并行）收集器，针对新生代，采用复制收集算法**
>
> **Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理
> **
>
> **Parallel** **Old（并行）收集器，针对老年代，标记整理**
>
> **CMS收集器，基于标记清理
> **
>
> **G1收集器：整体上是基于标记** **整理** **，局部采用复制
> **
>
> **综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。**

### 10、java.lang中不能被继承的类

> public final class Character
>
> public static final class Character.UnicodeBlock
>
> public final class Class<T>
>
> public final class Compile
>
> public final class ProcessBuilder
>
> public final class RuntimePermission
>
> public final class StackTraceElement
>
> public final class StrictMath

### 11、J2EE中常用的名词解释

> 1.web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接和容器中的环境变量接接口互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。
>
> 2.Web container：实现J2EE体系结构中Web组件协议的容器。这个协议规定了一个Web组件运行时的环境，包括安全，一致性，生命周期管理，事务，配置和其它的服务。一个提供和JSP和J2EE平台APIs界面相同服务的容器。一个Web container 由Web服务器或者J2EE服务器提供。
>
> 3.EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。一个实现了J2EE体系结构中EJB组件规范的容器。 这个规范指定了一个Enterprise bean的运行时环境，包括安全，一致性，生命周期，事务， 配置，和其他的服务。
>
> 4.JNDI：（Java Naming & Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。
>
> 5.JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。
>
> 6.JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。
>
> 7.JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。
>
> 8.RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。RMI-IIOP出现以前，只有RMI和CORBA两种选择来进行分布式程序设计。RMI-IIOP综合了RMI和CORBA的优点，克服了他们的缺点，使得程序员能更方便的编写分布式程序设计，实现分布式计算。首先，RMI-IIOP综合了RMI的简单性和CORBA的多语言性（兼容性），其次RMI-IIOP克服了RMI只能用于Java的缺点和CORBA的复杂性（可以不用掌握IDL）。