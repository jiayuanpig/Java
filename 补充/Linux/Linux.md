# Linux

## 目录分析

<img src="https://images2018.cnblogs.com/blog/1398985/201808/1398985-20180817160545482-534040573.jpg" alt="Linux目录结构" style="zoom: 67%;" />

> **/bin：**是Binary的缩写，这个目录存放着系统必备执行命令
> **/boot：**这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文 件，自己的安装别放这里
> **/dev：** Device(设备)的缩写， 该目录下存放的是Linux的外部设备，在Linux中访问设备的 方式和访问文件的方式是相同的。
> **/etc：** 所有的系统管理所需要的配置文件和子目录。
> **/home：** 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录 名是以用户的账号命名的。
>
> **/lib：**系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。
> **/lost+found：**这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。
> **/media：** linux系统会自动识别一些设备， 例如U盘、光驱等等，当识别后， linux会把识别的设备挂载到这个目录下。
> **/misc:** 该目录可以用来存放杂项文件或目录，即那些用途或含义不明确的文件或目录可 以存放在该目录下。
> **/mnt：** 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/上，然后进入该目录就可以查看光驱里的内容了。
> **/net** 存放着和网络相关的一些文件.
> **/opt：** 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可 以放到这个目录下。默认是空的。
> **/proc：**这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这 个目录来获取系统信息。
> **/selinux：**这个目录是Redhat/CentOS所特有的目录， Selinux是一个安全机制，类似于 windows的防火墙
> **/srv：** service缩写，该目录存放一些服务启动之后需要提取的数据。
> **/sys：** 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。
>
> **/root：** 该目录为系统管理员，也称作超级权限者的用户主目录。
> **/sbin：** s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。
> **/tmp：** 这个目录是用来存放一些临时文件的。
> **/usr：** 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。
> **/var：** 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。



## 命令行

### VIM编辑器

编辑器三种模式

- 正常模式：可以使用快捷键

- 编辑模式：可以编辑

- 命令行模式：




`vim 文件名`进入编辑器；按下`i`进入编辑模式；在正常模式下按`:`进入命令行模式；esc退出到正常模式

参数：`q`退出程序，`w`保存文件



### 开机、重启、用户登录注销

关机：shutdown -h now	或	halt

一分钟后关机：shutdown -h 1

重启：shutdown -r now	或	reboot

注意：在关机前先输入`sync`，将内存数据写入磁盘，防止数据丢失



### 用户、组和权限管理

#### 用户和组

**用户必须拥有一个组，不能独立于组外。用户创建的文件默认所在组为该用户所在组**



普通用户登录后输入`su - 用户名`切换身份，返回原身份`exit`（权限高转权限低不需要密码）

注销：logout



添加用户：useradd 用户名

添加用户和指定家目录：useradd -d 指定目录 用户名

添加用户和对应组：useradd -g 组名 用户名

给用户添加密码：passwd 用户名

删除用户（保留家目录）：userdel 用户名

删除用户（不保留家目录）：userdel -r 用户名

查询用户信息：id 用户名



增加组：groupadd 组名

删除组：groupdel 组名

修改用户组：usermod -g 组名 用户名



修改文件所有者：chown 用户名 文件名

修改文件所在组：chgrp 组名 文件名

修改文件所有者和所在组：chown 用户名:组名 文件名



**目录：/etc/passwd用户配置文件；/etc/shadow口令配置文件；/etc/group组配置文件**



#### 权限

示例：

```linux
ls -l（显示文件列表）
-rwxrw-r-- 1 root root 1213 3月 18 09:39 hello.txt
```

> 第0位：文件类型（d目录-普通文件l软连接c字符设备【键盘、鼠标】b块文件【硬盘】）
>
> 第1-3位：所有者权限（r可读w可写x可执行）
>
> 第4-6位：所在组权限
>
> 第7-9位：所有人权限
>
> 1表示文件对应硬链接数为1或者目录的子目录数为1
>
> root root表示 用户和组
>
> 1213表示文件大小（字节）



变更权限：`chmod u=rwx,g=rx,o=x`（u所有者g所在组o其他人a所有人）

​		等价于`chmod 751`（r 4；w 2；e 1）





### 实用指令

#### 运行级别（七种）

配置默认级别：/etc/inittab	`id:5:initdefault:`

> 0：关机
>
> 1：单用户（可以找回密码）
>
> 2：多用户无网络
>
> **3：多用户有网络**
>
> 4：空白（保留级别）
>
> **5：图形界面**
>
> 6：系统重启

切换级别：init 3



#### 帮助指令

man 命令

help 命令



#### 通用指令

清屏： clear

执行退出： exit

退出当前命令： ctrl+c 彻底退出



#### 文件目录类

显示当前目录绝对路径：pwd

查看文件：ls（参数：`-a`所有文件，包括隐藏文件；`-l`以列表形式展示）

当前目录和上层目录： ./ ../

主目录： ~/

切换目录： cd

创建目录：mkdir 目录名（参数：`-p`创建多级目录）

删除目录：rmdir 目录名（参数：`-rf`删除非空目录）

创建软链接：ln -s 目录/文件 软连接名



创建文件：torch 文件名

复制文件：cp 文件名 目的地址（参数：`-r`递归拷贝）

删除文件：rm 文件名（参数：`-r`递归删除；`-f`强删不提示）

重命名或移动文件：mv 文件名 文件名/目录

查看文件（只读）：cat 文件名（参数：`-n`显示行号	管道符：`|more`分页浏览）

全屏查看：more 文件名

分屏查看（适用大文件）：ess 文件名

查看文件开头内容：head 文件名（参数：`-n 5`查看前5行内容，默认为10）

查看文件尾部内容：tail 文件名（参数：`-n 5`查看后5行内容，默认为10；`-f`追踪更新）





内容添加：ls > 文件名（ls显示的内容写入到指定文件，覆盖原内容）ls >> 文件名（内容追加）



打印字符串：echo 输出内容



查看执行过的历史指令：history

执行编号为多少的指令：！编号



#### 时间日期类

`date "+%Y-%m-%d %H:%M:%S"`显示当前年月日 时分秒

`date -s 字符串时间`设置当前系统时间

`cal`查看日历信息



#### 搜索查找类

可以使用通配符

> “？”可替代单个字符。
>
> “*”可替代任意多个字符。
>
> 方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC]



`find 指定目录 <指定条件：-name；-user；-size> 指定内容`

`locate 文件名`快速定位文件路径（需要提前运行`updatedb`创建local数据库，使用find 直接搜索磁盘较慢）



过滤查找

grep 查找内容 源文件（参数：`-n`显示匹配行和行号；`-i`忽略大小写）

实例：在hello.txt中查找yes所在的行，及行号：`cat hello.txt | grep -n yes `



#### 压缩解压类

**不同方式的压缩级别不一样，对应的压缩效果和时间也有区别**

**方式一**

压缩：gzip 文件名（压缩后不保留源文件）

解压：gunzip 文件名（压缩文件后缀.gz）

**方式二**

压缩：zip 文件名（压缩后保留源文件）（参数：`-r`递归压缩）

解压：unzip 文件名（压缩文件后缀.zip）（参数：`-d 目录`解压位置）

**方式三**

打包：tar 文件名（后缀为.tar.gz）

（参数：`-c`产生.tar打包文件；`-v`显示详细信息；`-f`指定压缩文件名；`-z`打包且压缩；`-x`解包.tar文件）

常用组合：`-zcvf`打包；`-zxvf`解包



### 任务调度

示例：

```linux
//编写脚本文件/home/mytack.sh：将日历追加到mydate文件中
date >> /tmp/mydate
//授予权限
chmod 774 /home/mytack.sh
//任务调度
crontab -e
*/1 * * * * /home/mytack.sh
```

第一个*/n表示一个小时每个n分钟调用一次（0-59）

第二个*表示一天中第几个小时（0-23）

第三个*表示一个月中的第几天（1-31）

第四个*表示一年中的第几个月（1-12）

第五个*表示一周中的星期几（0-7，0和7都表示星期天）



### 进程管理

> 在Linux系统中，每个执行程序都是一个进程，每个进程分配一个id号
>
> 每个进程都对应一个父进程，父进程可以复制子进程
>
> 进程分为前台和后台运行，一般系统服务都是以后台进程存在

查看进程：ps（参数：-a显示终端所有进程；-u以用户格式显示进程；-x显示后台进程参数）

​	可以使用管道过滤：ps -aux | grep XXX

杀死进程：kill 进程号（参数：`-9`强制终止）/killall 进程名称

查看进程树：pstree（参数：-p显示pid；-u显示进程所属用户）

监视进程：top



查看服务：service 服务名

查看服务运行级别：chkconfig --list | grep XXX

修改服务运行级别：chkconfig --level 5 服务名 on/off



查看网络情况：netstat





### 搭建环境和安装软件

rpm：互联网下载包的打包和安装工具（参数：-q是否安装-a所有软件包-i软件包信息-l查询软件包文件-e卸载）

yum：基于rpm的管理器，一次性下载所有依赖的rpm文件



#### java相关软件安装

1. 解压缩到/opt
2. 配置环境变量



相关软件：jdk、tomcat（注意开放端口8080）、eclipse、mysql





# shell编程

**shell 不等于shell编程**

Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。

Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。



**Shell 脚本（shell script），是一种为 shell 编写的脚本程序。**

编写shell程序用来管理服务器集群或运行程序、维护服务器，shell可以用来启动、挂起、停止甚至编写一些程序



## 运行shell脚本

**1、作为可执行程序**（运行前需要有执行权限）

```shell
#!/bin/bash
echo "Hello World !"
```

将上面的代码保存为 test.sh，并 cd 到相应目录：

```shell
chmod +x ./test.sh  #使脚本具有执行权限
./test.sh  #执行脚本
```

注意，一定要写成 **./test.sh**，而不是 **test.sh**，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。



**2、作为解释器参数**

这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：

```
/bin/sh test.sh
/bin/php test.php
```

这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。





## shell脚本语法

### **变量**

**定义变量**

定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：

```shell
#!/bin/bash

your_name="runoob.com"
#定义数组
my_array=(A B "C" D)
array_name[0]=value0
array_name[1]=value1
array_name[2]=value2

#只读变量：使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。
myUrl="https://www.google.com"
readonly myUrl

#查看变量
set
#删除变量，不能删除只读变量
unset variable_name

RESULT = `ls -l /home`(将执行结果存入变量)
RESULT = $(ls -l /home)(与上等价)

export 变量名=变量值(将shell变量输出为环境变量)
source 配置文件(让修改的配置信息立即生效)
echo $变量名(查询环境变量值)
```

注意，变量名和等号之间不能有空格

除了显式地直接赋值，还可以用语句给变量赋值，如：

```
for file in `ls /etc`
或
for file in $(ls /etc)
```

以上语句将 /etc 下目录的文件名循环出来。

**使用变量**

使用一个定义过的变量，只要在变量名前面加美元符号即可，如：

```shell
your_name="qinjx"
echo $your_name
echo ${your_name}

#使用@ 或 * 可以获取数组中的所有元素，使用#获取字符串或数组长度
echo "数组的元素为: ${my_array[*]}"
echo "数组元素个数为: ${#my_array[*]}"

```

变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界

**变量类型**

运行shell时，会同时存在三种变量：

- **1) 局部变量** 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
- **2) 环境变量** 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
- **3) shell变量** shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

**shell字符串**

单引号字符串的限制：

- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
- 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

双引号的优点：

- 双引号里可以有变量
- 双引号里可以出现转义字符

**注释**

```shell
# 单行注释

:<<!
多行注释
!

# 如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。
```



### 参数

可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n**。**n** 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……



### 运算符

Shell 和其他编程语言一样，支持多种运算符，包括：

- 算数运算符：+ - * / % = == !=
- 关系运算符：-eq -ne -gt -lt -ge -le
- 布尔运算符：! -a -o
- 逻辑运算符：&& ||
- 字符串运算符
- 文件测试运算符

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。

expr 是一款表达式计算工具，使用它能完成表达式的求值操作。

例如，两个数相加(**注意使用的是反引号 ` 而不是单引号 '**)：

```shell
#!/bin/bash

val=`expr 2 + 2`
echo "两数之和为 : $val"

RESULT = $(((2+3)*4))
RESULT = $[(2+3)*4]
```

**关系运算符**只支持数字，不支持字符串，除非字符串的值是数字。

下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                  | 举例                         |
| :----- | :---------------------------------------------------- | :--------------------------- |
| -eq    | 检测两个数是否相等，相等返回 true。                   | `[ $a -eq $b ] `返回 false。 |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | `[ $a -ne $b ] `返回 true。  |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | `[ $a -gt $b ]` 返回 false。 |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | `[ $a -lt $b ]` 返回 true。  |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | `[ $a -ge $b ] `返回 false。 |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | `[ $a -le $b ] `返回 true。  |

**布尔运算符**

下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                | 举例                                     |
| :----- | :-------------------------------------------------- | :--------------------------------------- |
| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。                  |
| -o     | 或运算，有一个表达式为 true 则返回 true。           | [ $a -lt 20 -o $b -gt 100 ] 返回 true。  |
| -a     | 与运算，两个表达式都为 true 才返回 true。           | [ $a -lt 20 -a $b -gt 100 ] 返回 false。 |

**字符串运算符**

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

| 运算符 | 说明                                         | 举例                     |
| :----- | :------------------------------------------- | :----------------------- |
| =      | 检测两个字符串是否相等，相等返回 true。      | [ $a = $b ] 返回 false。 |
| !=     | 检测两个字符串是否相等，不相等返回 true。    | [ $a != $b ] 返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。        | [ -z $a ] 返回 false。   |
| -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | [ -n "$a" ] 返回 true。  |
| $      | 检测字符串是否为空，不为空返回 true。        | [ $a ] 返回 true。       |



### 流程控制

判断、分支、循环

```shell
#判断
if condition
then
    command1 
    command2
    ...
    commandN
else
    command
fi

if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi

#分支
case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2）
    command1
    command2
    ...
    commandN
    ;;
esac

#循环
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done

while condition
do
    command
done


```



### 函数

```shell
[ function ] funname [()]
{
    action;
    [return int;]
}
funname 参数
```



### 输入输出重定向

大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。

| 命令            | 说明                                               |
| :-------------- | :------------------------------------------------- |
| command > file  | 将输出重定向到 file。                              |
| command < file  | 将输入重定向到 file。                              |
| command >> file | 将输出以追加的方式重定向到 file。                  |
| n > file        | 将文件描述符为 n 的文件重定向到 file。             |
| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。 |
| n >& m          | 将输出文件 m 和 n 合并。                           |
| n <& m          | 将输入文件 m 和 n 合并。                           |
| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 |



和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。

Shell 文件包含的语法格式如下：

```shell
. filename   # 注意点号(.)和文件名中间有一空格

或

source filename
```



### 案例

```shell
#需求
: << !
	每天凌晨2：10备份数据库myDB 到/data/backup/db
	备份开始和结束给出提示信息
	备份后打包成.tar.gz格式，文件名为备份时间
	备份同时检查是否有10天以前的备份数据，有就将其删除
!

控制台：
vim /user/sbin/mysql_db_backup.sh

文件内容：
#!/bin/bash
echo "=====备份开始======"
echo "=====备份路径：$BACKUP/$DATETIME.tar.gz======"

#主机名、用户名、密码、数据库名
HOST=localhost
DB_USER=root
DB_PWD=root
DATABASE=myDB
#创建备份路径
#如果备份路径文件夹存在就使用，否则创建
[ ! -d "$BACKUP/$DATETIME"] && mkdir -p "$BACKUP/$DATETIME"
#执行mysql的备份指令
mysqldump -u${DB_USER} -p${DB_PWD} --host=$HOST $DATABASE | gzip > $BACKUP/$DATETIME/$DATETIME.sql.gz
#打包备份文件
cd $BACKUP
tar -zcvf $DATETIME.tar.gz $DATETIME
#删除10天前的备份文件
find $BACKUP -mtime +10 -name "*.tar.gz" -exec rm -rf {} \;
echo "=======备份成功========"


控制台：
//授予权限
chmod 774 /user/sbin/mysql_db_backup.sh
//任务调度
crontab -e
10 2 * * * /user/sbin/mysql_db_backup.sh


```







# Java开发掌握命令

![Java开发掌握命令](https://upload-images.jianshu.io/upload_images/4924478-11935519dec6d762?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 常见的shell编程





























