# 计算机网络

## 计算机网络体系结构

![计算机网络体系和协议](https://images2015.cnblogs.com/blog/983980/201611/983980-20161121173924409-1128983178.png)



### 1、OSI的七层模型（学术界）

**七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层**



- 物理层

物理层处于OSI的最底层，是整个开放系统的基础。物理层涉及通信信道上传输的原始比特流(bits)，它的功能主要是为数据端设备**提供传送数据的通路以及传输数据**。

- 数据链路层

数据链路层的主要任务是实现**计算机网络中相邻节点之间**的可靠传输，把原始的、有差错的物理传输线路加上数据链路协议以后，构成逻辑上可靠的数据链路。需要完成的功能有**链路管理、成帧、差错控制以及流量控制**等。其中成帧是对物理层的原始比特流进行界定，数据链路层也能够对帧的丢失进行处理。

- 网络层

网络层涉及**源主机节点到目的主机节点之间**可靠的网络传输，它需要完成的功能主要包括**路由选择、网络寻址、流量控制、拥塞控制、网络互连**等。

- 传输层

传输层起着承上启下的作用，涉及**源端节点到目的端节点之间**可靠的信息传输。传输层需要解决跨越网络连接的建立和释放问题，建立连接时需要三次握手，释放连接时需要四次挥手。传输层的主要任务是通过通信子网的特性，最佳地利用网络资源，并以可靠与经济的方式为2个端系统的会话层之间建立一条连接通道，以透明地传输报文。传输层向上一层提供一个**可靠的端到端的服务**，使会话层不知道传输层以下的数据通信的细节。传输层只存在端系统中，**传输层以上各层就不再考虑信息传输的问题了**。

- 会话层

会话层的主要功能是负责**应用程序之间建立、维持和中断会话**，同时也提供对设备和结点之间的会话控制，协调系统和服务之间的交流，并通过提供单工、半双工和全双工3种不同的通信方式，使系统和服务之间有序地进行通信。

- 表示层

表示层关心所传输数据信息的格式定义，其主要功能是把**应用层提供的信息变换为能够共同理解的形式**，提供字符代码、数据格式、控制信息格式、加密等的统一表示。

- 应用层

应用层为OSI的最高层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，**完成一系列业务处理所需的服务**。



### 2、TCP/IP的四层模型

**TCP/IP协议是一个开放的网络协议簇**，它的名字主要取自最重要的网络层IP协议和传输层TCP协议。TCP/IP协议定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。

TCP/IP参考模型采用4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求，这4个层次分别是：**网络接口层、互联网层(IP层)、传输层(TCP层)、应用层**。



- 网络接口层

TCP/IP协议对网络接口层没有给出具体的描述，网络接口层对应着物理层和数据链路层。

- 互联网层 ( IP层 )

互联网层是整个TCP/IP协议栈的核心。它的功能是把**分组发往目标网络或主机**。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。互联网层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，互联网层还需要完成拥塞控制的功能。

- 传输层 ( TCP层 )

TCP层负责在**应用进程之间建立端到端的连接和可靠通信**，它只存在与端节点中。TCP层涉及两个协议，TCP和UDP。其中，TCP协议提供面向连接的服务，提供按字节流的有序、可靠传输，可以实现连接管理、差错控制、流量控制、拥塞控制等。UDP协议提供无连接的服务，用于不需要或无法实现面向连接的网络应用中。

- 应用层

应用层为Internet中的各种网络应用提供服务。



### 3、五层模型（工业界）（最重要）

**五层：物理层、数据链路层、网络层、传输层、应用层**





## 网络分析示例

访问www.baidu.com为例：（基于四层模型）

1、应用层（DNS/HTTP）：通过应用层的DNS协议解析为对应的IP地址，与此同时，应用层的HTTP协议也使用IP地址

2、传输层（TCP/UDP）：端口

3、互联网层（ARP/IP）：ARP将IP地址解析为对应的MAC地址

4、网络接口层（以太网/无线LAN）









## 常见网络协议

### 1、协议簇：TCP/IP

#### IP协议

寻址和路由：确定对方的IP地址和最佳路由；不可靠传输，可靠传输交由上层的TCP协议负责；数据包的分片和重组。

##### IP数据报

<img src="https://img-blog.csdn.net/20181001210317800?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDU4NTkw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="ip数据报" style="zoom: 33%;" />

##### IPv4分类

![IP地址分类](https://img-blog.csdn.net/20180710105238320?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNzMw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



A类地址（0-127）用于大型网络，B类地址（128-191）用于中型网络，C类地址（192-223）用于小型网络，D类地址（224-239）是多播地址，E类地址（240-255）是保留地址。

特殊地址：**主机号为全0时用于表示网络地址，主机号为全1时用于表示广播地址。**这两个主机号不能用来标识主机。

注意：127.0.0.1表示环回地址，命名为localhost。ping 127.0.0.1来测试本机TCP/IP是否正常。



##### IP地址和MAC地址

> IP地址一般情况下容易修改和变动，具有随意性，不能在网络上固定标识一台设备。
>
> MAC地址一般情况出厂时由厂家烧录到网卡中，不容易修改，在局域范围内容易唯一定位一台设备。
>
> 从拓扑结构和分层上分析，IP地址属于网络层，主要功能在广域网范围内路由寻址，选择最佳路由，而MAC地址属于数据链路层，适合于网络媒体上传输的数据帧。
>
> 注意：标识一个设备的三种方式：① 域名访问（www.baidu.com，应用层）；② 设备的IP地址访问（网络层）；③ 设备的MAC地址（在局域网当中唯一标识该设备，实际不用其访问，在网络接口层，具有固定的特性，不易发生紊乱现象）。



##### IPv6和IPv4

- 地址长度：IPv4协议具有32位（4字节）地址长度；IPv6协议具有128位（16字节）地址长度

- 地址的表示方法：IPv4地址是以小数表示的二进制数。 IPv6地址是以十六进制表示的二进制数。

- 地址配置：IPv4协议的地址可以通过手动或DHCP配置的。IPv6协议需要使用Internet控制消息协议版本6（ICMPv6）或DHCPv6的无状态地址自动配置（SLAAC）。

- 数据包的区别

  包的大小：IPv4协议的数据包需要576个字节，碎片可选 。IPv6协议的数据包需要1280个字节，不会碎片

  包头：IPv4协议的包头的长度为20个字节，不识别用于QoS处理的数据包流，包含checksum，包含最多40个字节的选项字段。IPv6协议的包头的长度为40个字节，包含指定QoS处理的数据包流的Flow Label字段，不包含checksum；IPv6协议没有字段，但IPv6扩展标头可用。

  数据包碎片：IPv4协议的数据包碎片会由转发路由器和发送主机完成。IPv6协议的数据包碎片仅由发送主机完成。

- DNS记录：IPv4协议的地址（A）记录，映射主机名；指针（PTR）记录，IN-ADDR.ARPA DNS域。IPv6协议的地址（AAAA）记录，映射主机名；指针（PTR）记录，IP6.ARPA DNS域

- IPSec支持：IPv4协议的IPSec支持只是可选的。IPv4协议有内置的IPSec支持。

- 地址解析协议：IPv4协议：地址解析协议（ARP）可用于将IPv4地址映射到MAC地址。IPv6协议：地址解析协议（ARP）被邻居发现协议（NDP）的功能所取代。

- 身份验证和加密：Pv6提供身份验证和加密，但IPv4不提供。



#### TCP协议

TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。该“连接”就是客户端和服务器的内存里保存的关于ip地址、端口号等对方的信息。TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。

**TCP报文结构**

![TCP报文结构](https://img-blog.csdn.net/20140609125220296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：

- URG：紧急指针（urgent pointer）有效。
- ACK：确认序号有效。
- PSH：接收方应该尽快将这个报文交给应用层。
- RST：重置连接。
- SYN：发起一个新连接。
- FIN：释放一个连接。

**TCP连接：四元组【源地址，源端口，目标地址，目标端口】**

##### TCP功能

**数据连接**：三次握手和四次挥手

**可靠传输**：实现的方式包括序号、确认、超时重传、滑动窗口等可靠传输机制

​	序号和确认：将发送的数据单元进行分组，排序，接收方收到后会发送确认信息给发送方

​	超时重传：发送方在一定时间内未收到确认信息就进行重新发送

​	滑动窗口：使用窗口储存多个分组，随着确认收到，窗口向前滑动。用来提高发送效率

**流量控制**：使用滑动窗口让发送方不要发送太快

**拥塞控制**：发送方根据网络情况控制数据注入网络的速度，主要措施：慢开始，拥塞避免，快恢复，快重传

​	慢开始：发送方以2^n函数逐步增大发送窗口

​	拥塞避免：当发送窗口达到一定程度就不再以指数形式增加，而是以线性函数方式增加

​	快恢复：当遇到阻塞后重新恢复，发送窗口变成原来一半，以拥塞避免方式增加发送窗口

​	快重传：接收端发送需要收到的数据序号，来让发送端重新发送

（注意：流量控制和拥塞控制区别：**流量控制**是某个**TCP接收方**针对其**TCP发送方**所采取的措施，而**拥塞控制**是**TCP发送方**针对**网络拥塞情况**所采取的措施。**流量控制**：用于**防止发送方发送过快而使接受方无法接受**；**拥塞控制**用于**抑制发送方的发送速率以防止其占用过多的网络资源**。）



##### 三次握手与四次挥手

TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接，采用四次挥手来关闭一个连接。

![三次握手和四次挥手](https://img.jbzj.com/file_images/article/201711/20171122145249972.jpg?20171022145314)

所谓**三次握手**(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。在socket编程中，客户端执行connect()时，将触发三次握手：即客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力正常。

> 补充：为什么恰好三次才能连接？
>
> 1：A发，B收， B知道A能发
> 2：B发，A收， A知道B能发收
> 3：A发，B收， B知道A能收



> 握手之前主动打开连接的客户端结束CLOSED阶段，被动打开的服务器端也结束CLOSED阶段，并进入LISTEN阶段。随后开始“三次握手”：
>
> ![三次握手](https://pics1.baidu.com/feed/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg?token=c86d4509157378798ebbccbe843486d1&s=9746F8123F5754CA48D574DA0300D0B2)
>
> （1）首先**客户端向服务器端发送一段TCP报文**，其中：
>
> 标记位为SYN，表示“请求建立新连接”;
>
> 序号为Seq=X（X一般为1）；随后客户端进入SYN-SENT阶段。
>
> （2）**服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文**，其中：
>
> 标志位为SYN和ACK，表示“确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）；
>
> 序号为Seq=y；确认号为Ack=x+1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值；随后服务器端进入SYN-RCVD阶段。
>
> （3）**客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文**。其中：
>
> 标志位为ACK，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）；
>
> 序号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值；确认号为Ack=y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值；随后客户端进入ESTABLISHED阶段。服务器收到来自客户端的“确认收到服务器数据”的TCP报文之后，明确了从服务器到客户端的数据传输是正常的。结束SYN-SENT阶段，进入ESTABLISHED阶段。
>
> 在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性。一旦出现某一方发出的TCP报文丢失，便无法继续"握手"，以此确保了"三次握手"的顺利完成。



所谓**四次挥手**(four-way handshake)，就是指TCP的连接的拆除过程需要发送四个包，客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。

> **理解：**
>
> TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。客户端或者服务端皆可以主动发送指令告诉对方，我要关闭连接了，比如：
> 客户端：我要关闭连接了（客户端发起Close）
> 服务端：好，你关吧（服务端收到关闭指令，回了一个ACK）【此时客户端不可以向服务端传输数据，但是服务端仍然可以向客户端传输数据】
> 服务端：我传完所有数据啦（发送一个FIN段来关闭向客户端传输方向上的连接）
> 客户端：哦，好的，知道（发送ACK确认关闭连接）
>
> 注意：接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，它只负责“搬运”。
>
> **具体流程：**
>
> ![四次挥手](https://pics5.baidu.com/feed/48540923dd54564e5260495ce0006487d0584fb6.jpeg?token=c3a743af38e25ff66deb6a07891be58e&s=C584FC1A71CFF4EE1A75A45203007073)
>
> 挥手之前主动释放连接的客户端结束ESTABLISHED阶段。随后开始“四次挥手”：
>
> （1）首先客户端想要释放连接，向服务器端发送一段TCP报文，其中：
>
> 标记位为FIN，表示“请求释放连接“；
>
> 序号为Seq=U；随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。注意：这里不发送的是正常连接时传输的数据(非确认报文)，而不是一切数据，所以客户端仍然能发送ACK确认报文。
>
> （2）服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中：
>
> 标记位为ACK，表示“接收到客户端发送的释放连接的请求”；
>
> 序号为Seq=V；确认号为Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值；随后服务器端开始准备释放服务器端到客户端方向上的连接。客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段
>
> 前"两次挥手"既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了
>
> （3）服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中：
>
> 标记位为FIN，ACK，表示“已经准备好释放连接了”。注意：这里的ACK并不是确认收到服务器端报文的确认报文。
>
> 序号为Seq=W；确认号为Ack=U+1；表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。
>
> （4）客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中：
>
> 标记位为ACK，表示“接收到服务器准备好释放连接的信号”。
>
> 序号为Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。确认号为Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号Seq值作为本段报文确认号的值。随后客户端开始在TIME-WAIT阶段等待2MSL
>
> 为什么要客户端要等待2MSL呢？见后文。
>
> 服务器端收到从客户端发出的TCP报文之后结束LAST-ACK阶段，进入CLOSED阶段。由此正式确认关闭服务器端到客户端方向上的连接。
>
> 客户端等待完2MSL之后，结束TIME-WAIT阶段，进入CLOSED阶段，由此完成“四次挥手”。
>
> **为什么客户端在TIME-WAIT阶段要等2MSL?**
>
> 为的是确认服务器端是否收到客户端发出的ACK确认报文
>
> 当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。
>
> 服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；
>
> 如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。
>
> 所以，客户端要经历时长为2SML的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因





##### TCP与UDP区别

TCP和UDP都是传输层用来传输数据包的协议

UDP：不可靠传输

> UDP全称是用户数据报协议，有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。
>
> 特点：**面向无连接**，不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。**提供了单播，多播，广播的功能**，UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式 。**面向报文**，发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。
>
> 优缺点：头部开销小，传输效率高，支持多播；不可靠
>
> 应用场景：实时应用，例如电话、直播

TCP：可靠传输

> TCP协议全称是传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议
>
> 特点：**面向连接**，数据传输前后需要建立和断开连接。**仅支持单播传输**，每条TCP传输连接只能有两个端点，只能进行点对点的数据传输。**面向字节流**，TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。**可靠传输**，对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。**提供拥塞控制**，当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。**提供全双工通信**，TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）。
>
> 优点：可靠；开销大，不支持多播
>
> 应用场景：文件传输



#### 客户端与服务器端交互过程（Java）？？？

1. 服务器端创建套接字（socket）
2. 服务器端将套接字和ip、端口绑定
3. 服务器端进入监控状态，等待用户发起请求
4. 接受客户端请求
5. 向客户端发送数据
6. 服务器端关闭套接字



系统和java如何实现和使用tcp

socket，本意为插座，包括插头和底座两个部分。所以socket也包括两个部分，分别是文件描述符fd和网络协议栈。

​	fd：（远程ip，远程端口，本地ip，本地端口，协议）

系统API：socket、connect、send、recvbind，listen、accept、recv、close

client：socket、connect、read/recv、close

server：socket、bind、listen、accept、send/write、close



端口只有65535，为什么可以做到几百万连接？

客户端read/recv，服务器write/send

二者都是系统调用，read和write将套接字当作文件，有区别























### 2、应用层协议：HTTP协议

HTTP协议，即超文本传输协议，基于TCP/IP通信协议来传输数据，工作于客户端-服务端架构上，通过URL向Web服务器（Apache服务器等）传输请求并得到响应。默认端口为80，也可以设置为8080等。



#### HTTP特点

**HTTP是无连接**：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

**HTTP是媒体独立的**：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。

**HTTP是无状态：**HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。



#### HTTP结构

请求报文和响应报文都是由以下4部分组成

1. 请求行

2. 请求头

3. 空行

4. 消息主体

具体结构

##### http请求头：url、请求数据

**请求报头**

请求报头通知服务器关于客户端求求的信息，典型的请求头有：

- Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机

- User-Agent：发送请求的浏览器类型、操作系统等信息

- Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息

- Accept-Encoding：客户端可识别的数据编码

- Accept-Language：表示浏览器所支持的语言类型

- Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如这是为Keep-Alive则表示保持连接。

- Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。

  <img src="https://images2017.cnblogs.com/blog/1090126/201711/1090126-20171115074856609-255880765.png" alt="http请求" style="zoom:67%;" />

##### http响应头：状态码、响应正文

**响应报头**

用于服务器传递自身信息的响应，常见的响应报头：

- Location：用于重定向接受者到一个新的位置，常用在更换域名的时候
- Server：包含可服务器用来处理请求的系统信息，与User-Agent请求报头是相对应的



![http响应](https://images2017.cnblogs.com/blog/1090126/201711/1090126-20171115074903718-2136115327.png)

##### http请求行

- 实体报头用来定于被传送资源的信息，既可以用于请求也可用于响应。请求和响应消息都可以传送一个实体，常见的实体报头为：
- Content-Type：发送给接收者的实体正文的媒体类型
- Content-Lenght：实体正文的长度
- Content-Language：描述资源所用的自然语言，没有设置则该选项则认为实体内容将提供给所有的语言阅读
- Content-Encoding：实体报头被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。
- Last-Modified：实体报头用于指示资源的最后修改日期和时间
- Expires：实体报头给出响应过期的日期和时间

##### **空行**

http协议规定的格式，一般采用\r\n

 

##### **消息主体**

一般用于http的post method。通过实体报头规定消息主体的格式内容

- Content-Type=text/plain该实体报头规定了消息主体的数据是纯文本格式
- Content-Type=application/x-www-form-urlencoded，定义为Key=value格式
- Content-Type=application/json，定义为序列化为的json字符串
- Content-Type= multipart/form-data，定义为表单数据提交，该格式比较复杂



#### **HTTP请求方式**

一共八种请求方式：get、post、head、put、delete、connect、options、trace

<img src="https://images2018.cnblogs.com/blog/1445861/201807/1445861-20180723010545712-61214685.png" alt="img" style="zoom: 80%;" />

其中较为常用的为get、post、delete和put，这大致对应着对该资源的查、改、删、增四个操作。

> **1）Get请求用于向服务器进行信息获取，是安全和幂等的。**它仅仅是为了获取信息，不会影响资源的状态；所谓幂等，即对于同一个URL的多个请求返回的结果都一致。
>
> **get请求会将数据附在URL之后，以？来进行分割，参数之间以&来进行连接。**对于非英文字母/数字等，都需要进行格式的转换。而由于其在URL进行拼接，对于涉及到密码等请求，是不安全的。
>
> **在HTTP协议中对URL长度并没有作出限制，而URL的最大长度其实和用户浏览器以及web服务器有关。如IE为2048，Google为8182，Apache(Server)为8192。**
>
> 2）**Post请求表示向服务器提交数据的一种请求，可能修改服务器上的资源**，类似数据库的insert一样。**post对于数据的提交是放置在http包的包体当中的**。**理论上post请求是没有大小限制的，起限制作用的是服务器处理程序的处理能力**。如IIS 6.0默认post数据最大为200KB，每个表单限制为100KB。**post 的安全性比get高。**
>
> 3）Put请求也是向服务端发送数据从而改变信息，类似于数据库的update一般。
>
> 4）Delete请求就是删除某一资源的，类似于数据库的delete操作。



#### HTTP状态

> 1xx：指示信息--表示请求已接收，继续处理
>
> 2xx：成功--表示请求已被成功接收、理解、接受
>
> 3xx：重定向--要完成请求必须进行更进一步的操作
>
> 4xx：客户端错误--请求有语法错误或请求无法实现
>
> 5xx：服务器端错误--服务器未能实现合法的请求

**举例**

- 100：这个状态码是告诉客户端应该继续发送请求，这个临时响应是用来通知客户端的，部分的请求服务器已经接受，但是客户端应继续发送求请求的剩余部分，如果请求已经完成，就忽略这个响应，而且服务器会在请求完成后向客户发送一个最终的结果
- 200：这个是最常见的http状态码，表示服务器已经成功接受请求，并将返回客户端所请求的最终结果
- 202：表示服务器已经接受了请求，但是还没有处理，而且这个请求最终会不会处理还不确定
- 204：服务器成功处理了请求，但没有返回任何实体内容 ，可能会返回新的头部元信息
- 301：客户端请求的网页已经永久移动到新的位置，当链接发生变化时，返回301代码告诉客户端链接的变化，客户端保存新的链接，并向新的链接发出请求，已返回请求结果
- 404：请求失败，客户端请求的资源没有找到或者是不存在
- 500：服务器遇到未知的错误，导致无法完成客户端当前的请求。
- 503：服务器由于临时的服务器过载或者是维护，无法解决当前的请求



### 3、HTTPS协议

我们知道，HTTP请求都是明文传输的，所谓的明文指的是没有经过加密的信息，如果HTTP请求被黑客拦截，并且里面含有银行卡密码等敏感数据的话，会非常危险。为了解决这个问题，Netscape 公司制定了HTTPS协议，HTTPS可以将数据加密传输，也就是传输的是密文，即便黑客在传输过程中拦截到数据也无法破译，这就保证了网络通信的安全。

#### 密码学基础

**明文**： 明文指的是未被加密过的原始数据。
**密文**：明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密，得到原始的明文。
**密钥**：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥，分别应用在对称加密和非对称加密上。

**对称加密**：对称加密又叫做私钥加密，即**信息的发送方和接收方使用同一个密钥去加密和解密数据**。对称加密的特点是**算法公开**、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。
 	其加密过程如下：**明文 + 加密算法 + 私钥 => 密文**
 	解密过程如下：   **密文 + 解密算法 + 私钥 => 明文**

**对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。**
其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。

**非对称加密**：非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而**非对称加密使用一对密钥，即公钥和私钥，且二者成对出现**。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。
 被公钥加密过的密文只能被私钥解密，过程如下：
 **明文 + 加密算法 + 公钥 => 密文， 密文 + 解密算法 + 私钥 => 明文**
 被私钥加密过的密文只能被公钥解密，过程如下：
 **明文 + 加密算法 + 私钥 => 密文， 密文 + 解密算法 + 公钥 => 明文**

由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。
 非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
 在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。



#### HTTPS

**HTTPS协议 = HTTP协议 + SSL/TLS协议**，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。

> SSL的全称是Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL，其最新的版本是3.0
>
> TLS的全称是Transport Layer Security，即安全传输层协议，最新版本的TLS（Transport Layer Security，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。

HTTPS为了兼顾安全与效率，**同时使用了对称加密和非对称加密**。**数据是被对称加密传输的**，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，**采用非对称加密对该密钥进行加密传输**，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。



#### 通信过程

**HTTPS在传输的过程中会涉及到三个密钥：**服务器端的公钥和私钥，用来进行非对称加密；客户端生成的随机密钥，用来进行对称加密

> 一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步：
>
> 1. 客户端向服务器发起HTTPS请求，连接到服务器的**443端口**
>
> 2. 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，**服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人**。
>
> 3. 服务器将自己的公钥发送给客户端。
>
> 4. 客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
>
> 5. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
>
> 6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
>
> 7. 然后服务器将加密后的密文发送给客户端。
>
> 8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。















