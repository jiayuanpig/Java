# 命令行模式

简单的说命令模式就是将一个"请求"封装成一个对象，通过这个对象直接就能找到对应的执行命令。

**优点:**

好处是对于需要重复修改或实现的一些固定的操作，可以很方便的去执行，而不用抽丝剥茧的每次都和细分后的环节打交道，只需要和一个接受者打交道就行了。

比如客户经常需要频繁的改需求，如果让客户每次都和美工组或者程序猿直接沟通，偶尔还好，要是次数多了就会显得很麻烦，而如果客户直接把他的想法告诉一个固定的人，这个人接收到客户的想法后直接就可以调用相应的对象去执行。

**缺点：**

如果客户要不断实现的需求有很多种类，那就得不断的增加相应的功能实现，就会弄得很麻烦。



## 代码分析

<img src="https://img2018.cnblogs.com/blog/1151930/201910/1151930-20191023182752429-250241950.png" alt="img" style="zoom:80%;" />



干活前得先把人凑齐了，所以先组建一个项目组

```java
//项目组
public abstract class Group {
	//规定项目组具备的功能,增删改查四个功能
    abstract void find();
    abstract void add();
    abstract void delet();
    abstract void change();
}
```

人凑齐了需要进行分工和准备工具，这里分成了需求、美工、和代码三个组，每个组都实现了项目组里的功能

```java
//代码组
public class Code extends Group {
    @Override
    void find() {
        System.out.println("查到代码组");
    }

    @Override
    void add() {
        System.out.println("实现一个代码功能");
    }

    @Override
    void delet() {
        System.out.println("删除一个代码功能");
    }

    @Override
    void change() {
        System.out.println("修改一个代码功能");
    }
}
//需求组
public class Require extends Group {
    @Override
    void find() {
        System.out.println("查找到需求组");
    }

    @Override
    void add() {
        System.out.println("增加一个需求");
    }

    @Override
    void delet() {
        System.out.println("删除一个需求");
    }

    @Override
    void change() {
        System.out.println("修改一个需求");
    }

}
//美工组
public class Ui extends Group {
    @Override
    void find() {
        System.out.println("查找到美工组");
    }

    @Override
    void add() {
        System.out.println("增加一个美工页面");
    }

    @Override
    void delet() {
        System.out.println("删除一个美工页面");

    }

    @Override
    void change() {
        System.out.println("修改一个美工页面");

    }
}
```

人和工具都有了，现在需要从项目组里选出一个人来和客户进行对接，客户有什么想法直接告诉这个人就行了，这样就不需要去和代码组或者美工这些人沟通了

```java
/*该类是项目组中出的一个项目负责人也就是接收人，当这个接收人接到了客户的命令的时候，根据这个命令执行相应的动作*/
public class GroupMan {
    Command command;
    //得到客户命令
    public void getCommand(Command command){
        this.command = command;
    }
	//执行方法
    public void action(){
        command.execute();
    }
}
```

客户可以直接把功能命令告诉这个接收人，那么现在需要一个功能命令

```java
public abstract class Command {
	//命令中的执行方法，执行的具体实现由项目组中的分组分别去实现
     abstract void execute();
}
```

功能命令需要具体的功能去实现它，比如说增加一个代码功能或者删除一个美工图片

这里先实现一个"增加代码功能"的功能命令

```java
public class AddCode extends Command {
    Code code = new Code();//该功能由代码组的人员去实现
    @Override
    void execute() {
        code.find();
        code.add();
    }
}
```

其实从这里就可以看出这个命令模式的缺点了，如果客户后面要增加的功能命令有好多，那么这里就需要实现很多具体的功能，这样就很繁琐了

下面就是整个项目动起来的效果了

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("客户给出一个命令:我需要增加一个代码功能");
        //产生命令
        Command command = new AddCode();
		//叫来项目对接人
        GroupMan groupMan = new GroupMan();
        //告诉项目对接人命令
        groupMan.getConmand(command);
        //项目对接人知道命令后去落实这个命令了:在这背后是这个对接人通知了Group组中的Code组去实现了这个功能
        groupMan.action();
    }
}
```