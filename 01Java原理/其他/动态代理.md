# 代理（Handler）



## 代理模式

代理(Proxy)是一种设计模式，提供了间接对目标对象进行访问的方式，即**通过代理对象访问目标对象**。这样做的好处是：可以在目标对象实现的功能上，增加额外的功能补充，即扩展目标对象的功能。

这就符合了设计模式的开闭原则，即在对既有代码不改动的情况下进行功能的扩展。

举个例子来说明代理的作用：明星与经纪人之间就是被代理和代理的关系，明星出演活动的时候，明星就是一个目标对象，他只要负责活动中的节目，而其他琐碎的事情就交给他的代理人(经纪人)



**Java中具体有三种代理模式：静态代理、动态代理和Cglib代理**



## 静态代理

创建一个接口，然后**创建被代理的类实现该接口**并且实现该接口中的抽象方法。之后再**创建一个代理类，同时使其也实现这个接口**。在**代理类中持有一个被代理对象的引用**，而后在代理类方法中调用该对象的方法。

（两个都实现一个接口的意义在于保证方法统一）

**使用静态代理很容易就完成了对一个类的代理操作。但是静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。**



**示例**

```java
//接口
public interface HelloInterface {
    void sayHello();
}
```

```java
//被代理类
public class Hello implements HelloInterface{
    @Override
    public void sayHello() {
        System.out.println("Hello zhanghao!");
    }
}
```

```java
//代理类：增强被代理类的方法
public class HelloProxy implements HelloInterface{
    private HelloInterface helloInterface = new Hello();
    @Override
    public void sayHello() {
        System.out.println("Before invoke sayHello" );
        helloInterface.sayHello();
        System.out.println("After invoke sayHello");
    }
}
```

```java
//使用
public static void main(String[] args) {
    HelloProxy helloProxy = new HelloProxy();
    helloProxy.sayHello();
}
    
输出：
Before invoke sayHello
Hello zhanghao!
After invoke sayHello
```



## 动态代理

使用反射机制实现动态代理。动态代理的主要特点就是能够在程序运行时JVM才为被代理对象生成代理对象。常说的动态代理也叫做JDK代理也是一种接口代理，JDK中生成代理对象的代理类就是Proxy，所在包是java.lang.reflect

**注意：优点是根据传入的类来统一代理实现方法增强。但是，代理对象不需要实现接口,但是被代理对象一定要实现接口,否则不能使用动态代理，因此这也算是这种方式的缺陷。**

动态代理原理：

​	前提：给定的接口和被代理类

​	实现功能：代理类实现InvocationHandler 接口，实现invoke方法（写增强的具体内容）

​	调用增强的功能：Proxy.newProxyInstance（被代理类，被代理类的父接口，代理类）



<img src="https:////upload-images.jianshu.io/upload_images/2109481-5bc36d36f5997da1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="动态代理流程图" style="zoom: 67%;" />





**示例**：**接口、被代理类不变**，我们构建一个handler类来实现InvocationHandler接口。

```java
public class ProxyHandler implements InvocationHandler{
    private Object object;
    public ProxyHandler(Object object){
        this.object = object;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Before invoke "  + method.getName());
        method.invoke(object, args);
        System.out.println("After invoke " + method.getName());
        return null;
    }
}
```

```java
//执行动态代理
public static void main(String[] args) {
    System.getProperties().setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");

    HelloInterface hello = new Hello();

    InvocationHandler handler = new ProxyHandler(hello);

    HelloInterface proxyHello = (HelloInterface) Proxy
        							.newProxyInstance(hello.getClass().getClassLoader(), 
                          							  hello.getClass().getInterfaces(), 
                          							  handler);

    proxyHello.sayHello();
}
输出：
    Before invoke sayHello
    Hello zhanghao!
    After invoke sayHello
```

通过Proxy类的静态方法newProxyInstance返回一个接口的代理实例。针对不同的代理类，传入相应的代理程序控制器InvocationHandler。

如果新来一个被代理类Bye，如：

```java
public interface ByeInterface {
    void sayBye();
}
public class Bye implements ByeInterface {
    @Override
    public void sayBye() {
        System.out.println("Bye zhanghao!");
    }
}
```

那么执行过程：

```java
public static void main(String[] args) {
    System.getProperties().setProperty("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");

    HelloInterface hello = new Hello();
    ByeInterface bye = new Bye();

    InvocationHandler handler = new ProxyHandler(hello);
    InvocationHandler handler1 = new ProxyHandler(bye);

    HelloInterface proxyHello = (HelloInterface) Proxy.newProxyInstance(hello.getClass().getClassLoader(), 
                       hello.getClass().getInterfaces(), 
                       handler);

    ByeInterface proxyBye = (ByeInterface) Proxy.newProxyInstance(bye.getClass().getClassLoader(),
                                                                  bye.getClass().getInterfaces(), 
                                                                  handler1);
    proxyHello.sayHello();
    proxyBye.sayBye();
}

输出：
Before invoke sayHello
Hello zhanghao!
After invoke sayHello

Before invoke sayBye
Bye zhanghao!
After invoke sayBye
```



**动态代理底层实现**

> 待填
>





## Cglib代理

上面的静态代理和动态代理模式有个相同点，就是都要求目标对象是实现一个接口的对象，然而并不是任何对象都会实现一个接口，也存在没有实现任何的接口的对象，这时就可以使用**继承目标类以目标对象子类的方式实现代理**，这种方法就叫做：Cglib代理，也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能的扩展。

**优点：不要求被代理类一定实现某个接口**

