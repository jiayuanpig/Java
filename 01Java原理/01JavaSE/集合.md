# 集合

**Map**接口（双列）和**Collection**接口（单列）是所有集合框架的父接口

Collection接口的子接口包括：Set接口和List接口

1. Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等
2. List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等

Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等



线程安全的类：Vector、HashTable、ConcurrentHashMap和Stack



### 继承关系

![集合继承关系](https://images2015.cnblogs.com/blog/1010726/201706/1010726-20170621004734695-988542448.png)

![集合继承关系](https://img-blog.csdn.net/20170602101121746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjgzODU3OTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

### Collection和Collections

Collection是集合类的上级接口

Collections是集合工具类，包含集合的静态方法，用于实现集合搜索、排序、线程安全等操作。不能实例化。



### 相关集合类区别

#### ArrayList 和 Vector 的区别

这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是**有序集合**，即存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以**按位置索引**来取出某个元素，并且其中的数据是**允许重复**的，这是与 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素。

ArrayList 与 Vector 的区别主要包括两个方面：

1. 同步性：
   Vector 是线程安全的，也就是说它的方法之间是线程同步（加了synchronized 关键字）的，而 ArrayList 是线程不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全的问题，所以效率会高一些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。
2. 数据增长：
   ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个人超过了容量时，就需要增加 ArrayList 和 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要去的一定的平衡。Vector 在数据满时（加载因子1）增长为原来的两倍（扩容增量：原容量的 2 倍），而 ArrayList 在数据量达到容量的一半时（加载因子 0.5）增长为原容量的 (0.5 倍 + 1) 个空间。


#### ArrayList和LinkedList的区别

1. LinkedList 实现了 List 和 **Deque 接口**，一般称为双向链表；ArrayList 实现了 List 接口，动态数组；
2. LinkedList 在插入和删除数据时效率更高，ArrayList 在查找某个 index 的数据时效率更高；
3. LinkedList 比 ArrayList 需要更多的内存；

#### Array 和 ArrayList 区别

1. Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。
2. Array 大小是固定的，ArrayList 的大小是动态变化的。
3. ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。

#### HashTable和HashMap的区别

二者都实现了Map、Cloneable和Serializable接口，负责存储键值对。底层都是由数组+链表+红黑树实现

区别：

- **HashMap可以存储null键和null值**，HashTable无论key还是value都不能为null
- HashMap线程不安全，但效率高，**HashTable线程安全**，但效率低
- HashMap继承AbstractMap类，HashTable继承Dictionary类
- HashTable比HashMap多提供elements()和contains()方法
- 二者初始容量和扩充方式也有区别，计算hash的方法也不一样

#### **ConcurrentHashMap**

线程安全，并且锁分离。**ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。**只要多个修改操作发生在不同的段上，它们就可以并发进行。

- 底层采用分段的数组+链表实现，线程**安全**
- 通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)
- Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术
- 有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁
- 扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容

#### LinkedHashMap

LinkedHashMap保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。

#### TreeMap

**TreeMap实现SortMap接口**，能够把它保存的记录根据键排序，默认是按键值的升序排序（自然顺序），也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，非同步的；

