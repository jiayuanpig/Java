# 序列化（Serializable）

一个java中的类只有实现了Serializable接口，它的对象才是可序列化的。如果要序列化某些类的对象，这些类就必须实现Serializable接口。Serializable是一个空接口，没有什么具体内容，它的目的只是简单的标识一个类的对象可以被序列化。



## **序列化是做什么的**

对象的生命周期常随着生成该对象的程序的终止而终止,有时候需要把内存中的各种对象状态(也就是实例变量,不是方法)保存下来并且可以在需要时再将对象恢复.虽然你可以用你自己的方法保存对象的状态,但是java提供了一种应该比我们好的保存对象状态的机制,那就是序列化

序列化的作用就是为了不同jvm之间共享实例对象的一种解决方案



例如

在没有序列化前，每个保存在堆（Heap）中的对象都有相应的状态（state），即实例变量（instance ariable）比如：

```java
Foo myFoo = new Foo(); 
myFoo.setWidth(37); 
myFoo.setHeight(70); 
```

当 通过下面的代码序列化之后，MyFoo对象中的width和Height实例变量的值（37，70）都被保存到foo.ser文件中，这样以后又可以把它 从文件中读出来，重新在堆中创建原来的对象。当然保存时候不仅仅是保存对象的实例变量的值，JVM还要保存一些小量信息，比如类的类型等以便恢复原来的对 象。

```java
FileOutputStream fs = new FileOutputStream("foo.ser"); 
ObjectOutputStream os = new ObjectOutputStream(fs); 
os.writeObject(myFoo); 
```

完整代码

```
import java.io.*;

public class  Box implements Serializable  
{  
    private int width;  
    private int height;  

    public void setWidth(int width){  
        this.width  = width;      
    }  
    public void setHeight(int height){  
        this.height = height;  
    }  
      
    public static void main(String[] args){  
        Box myBox = new Box();  
        myBox.setWidth(50);  
        myBox.setHeight(30);  
      
        try{  
            FileOutputStream fs = new FileOutputStream("foo.ser");  
            ObjectOutputStream os =  new ObjectOutputStream(fs);  
            os.writeObject(myBox);  
            os.close();  
        }catch(Exception ex){  
            ex.printStackTrace();  
        }  
    }  

}  
```



**serialVersionUID**
serialVersionUID的取值是Java运行时环境根据类的内部细节自动生成的。

**如果对类的源代码作了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。**

类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的serialVersionUID，也有可能相同。

为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。显式地定义serialVersionUID有两种用途：
　　a. 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；
　　b. 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。



**注意事项:**

   1).序列化时,只对对象的状态保存,而不管对象的方法
   2).当一个父类实现序列化时,子类自动序列化,不需要显式实现Serializable接口
   3).当一个对象的实例变量引用其他对象,序列化该对象时也把引用对象序列化.
   4).并非所有的对象都可以序列化.





## 使用场景

- 当想把的内存中的对象状态保存到一个文件中或者数据库中时候；
- 当想用套接字在网络上传送对象的时候；
- 当想通过RMI传输对象的时候；
- 对象克隆







transient修饰的变量在序列化中不会保存

