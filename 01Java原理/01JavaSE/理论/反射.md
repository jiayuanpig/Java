# 反射

>  反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。
>
>  
>
>  常见创建对象的两种方式：使用new关键字；使用反射
>
>  反射的创建效率要比new的低，通过反射时，先找查找类资源，使用类加载器创建，过程比较繁琐，所以效率较低



## 如何使用反射

| 类名          | 用途                                             |
| ------------- | ------------------------------------------------ |
| Class类       | 代表类的实体，在运行的Java应用程序中表示类和接口 |
| Field类       | 代表类的成员变量（成员变量也称为类的属性）       |
| Method类      | 代表类的方法                                     |
| Constructor类 | 代表类的构造方法                                 |

**获得类相关的方法**

| 方法                       | 用途                                                   |
| -------------------------- | ------------------------------------------------------ |
| asSubclass(Class<U> clazz) | 把传递的类的对象转换成代表其子类的对象                 |
| Cast                       | 把对象转换成代表类或是接口的对象                       |
| getClassLoader()           | 获得类的加载器                                         |
| getClasses()               | 返回一个数组，数组中包含该类中所有公共类和接口类的对象 |
| getDeclaredClasses()       | 返回一个数组，数组中包含该类中所有类和接口类的对象     |
| forName(String className)  | 根据类名返回类的对象                                   |
| getName()                  | 获得类的完整路径名字                                   |
| newInstance()              | 创建类的实例                                           |
| getPackage()               | 获得类的包                                             |
| getSimpleName()            | 获得类的名字                                           |
| getSuperclass()            | 获得当前类继承的父类的名字                             |
| getInterfaces()            | 获得当前类实现的类或是接口                             |

**获取成员变量**

```java
Field[] getFields()
Field getField(String name)  
    
Field[] getDeclaredFields()//获取所有的，不考虑修饰符
Field getDeclaredField(String name) 
```

**获取构造方法**

```java
Constructer<?>[] getConstructors()
Constructer<?>[] getConstructor(类<?>...)
    
Constructer<?>[] getDeclaredConstructors()
Constructer<?>[] getDeclaredConstructor(类<?>...)    
    
    constructor.newInstance(类<?>...)//创建对象
```

**获取成员方法**

```java
Method<?>[] getMethods()
Method<?>[] getMethod(类<?>...)
    
Method<?>[] getDeclaredMethods()
Method<?>[] getDeclaredMethod(类<?>...)   
```



**具体使用过程**

1. 通过一个全限类名创建一个对象
   1)   Class.forName(“全限类名”); 例如：com.mysql.jdbc.Driver Driver类已经被加载到 jvm中，并且完成了类的初始化工作就行了
   2）类名.class; 获取Class<？> clz 对象
   3）对象.getClass();

2. 获取构造器对象，通过构造器new出一个对象
   1）Class.getConstructor([String.class]);
   2）Con.newInstance([参数]);

3. 通过class对象创建一个实例对象（就相当与new类名（）无参构造器)
   1）Class.newInstance();

4. 通过class对象获得一个属性对象
   1)  Field c=class.getFields()：获得某个类的所有的公共（public）的字段，包括父类中的字段。
   2)  Field c=class.getDeclaredFields()：获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段 e.
5. 通过class对象获得一个方法对象
   1）Class.getMethod(“方法名”,class……parameaType);（只能获取公共的）
   2）Class.getDeclareMethod(“方法名”);（获取任意修饰的方法，不能执行私有）
   3）Method.setAccessible(true);（让私有的方法可以执行）
6. 让方法执行
   1）Method.invoke(obj实例对象,obj可变参数);-----（是有返回值的）



## 反射的优缺点

优点：
　　　反射提高了程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象，无需提前硬编码目标类
缺点：
　　（1）性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和扩展性要求很高的系统框架上，普通程序不建议使用。
　　（2）使用反射会模糊程序内内部逻辑：程序员希望在源代码中看到程序的逻辑，反射等绕过了源代码的技术，因而会带来维护问题。反射代码比相应的直接代码更复杂。





## 反射机制的作用和用途

**作用**

反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。

1. 在运行时判断任意一个对象所属的类
2. 在运行时构造任意一个类的对象
3. 在运行时判断任意一个类所具有的成员变量和方法
4. 在运行时调用任意一个对象的方法
5. 在运行时创建新类对象

**用途**

1. 各种框架用的最多的就是反射
2. 加载驱动
3. 读取配置文件



## 反射和工厂模式的区别

- 反射可以创建对象，获取类的所有属性和方法

- 工厂模式是将创建对象的权力交给工厂，而不是自己创建（将创建对象的权利剥夺了）

