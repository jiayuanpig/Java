# Java内存以及垃圾回收

**为什么要分配内存？**

java运行程序时，需要对程序分配内存空间。为了提高运算效率，java就划分了不同的内存区域，不同区域都有特定的数据处理方式和内存管理方式。Java内存区域主要划分为五个部分：**栈、堆、方法区、本地方法栈、寄存器**

**在哪垃圾回收？**

Java 内存运行时区域中的程序计数器、虚拟机栈、本地方法栈随线程而生灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由 JIT 编译器进行一些优化），因此这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。

而 Java 堆不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。



## 内存分配

![Java内存分配](https://upload-images.jianshu.io/upload_images/14923529-c0cbbccaa6858ca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

java运行程序时，需要对程序分配内存空间。为了提高运算效率，java就划分了不同的内存区域，不同区域都有特定的数据处理方式和内存管理方式。Java内存区域主要划分为五个部分：**虚拟机栈**、**堆**、**方法区（元数据区）**、**本地方法栈**、**程序计数器（寄存器）**

**虚拟机栈（Stack）**：**包括局部变量，对象的引用，方法调用**

​	JVM的进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就被称为**栈帧**，每当线程调用一个方法的时候就会向方法栈压入一个新帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。

​	**栈帧包括局部变量表、操作数栈、动态链接、方法出口**

**堆（heap）**：通过**new关键字和构造器创建的对象**放在堆空间（注意创建出来的对象只包含属于各自的成员变量，并不包括成员方法）。堆对象都有默认值，最后由垃圾回收器回收。

​	堆内存由程序员分配（很大），栈由系统分配（很小）；堆内存执行速度慢，易产生内存碎片

**方法区（method area）**：用于存储已经**被JVM加载的类信息、常量、静态变量、编译器编译后的代码**等数据

​	**方法区中含有常量池和静态域**

​	程序中的字面量如直接书写的100、"hello"和常量都是放在常量池中。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError

**本地方法栈**：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为**虚拟机使用到的 Native 方法服务**（和操作系统相关）。

**程序计数器**：程序计数器记录的是正在执行的虚拟机字节码指令地址，**分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。



==**方法区和堆都是各个线程共享的内存区域；虚拟机栈、本地方法栈和程序计数器都是线程私有**==



### 示例

**一个程序运行内存分配情况分析**

```Java
AppMain.java
    
//运行时, jvm 把appmain的代码全部都放入方法区
public class AppMain{
    public static void main(String[] args) { //main 方法本身放入方法区。
        Sample test1 = new Sample(" 测试1 ");   //test1是引用，所以放到栈区里， Sample是自定义对象应该放到堆里面
        Sample test2 = new Sample(" 测试2 ");

        test1.printName();
        test2.printName();
    }
}

public class Sample{//运行时, jvm 把appmain的信息都放入方法区
    private String name; //new Sample实例后， name 引用放入栈区里, name 对应的 String 对象放入堆里

    public Sample(String name) {
        this.name = name;
    }

    public void printName()   //在没有对象的时候，print方法跟随sample类被放入方法区里。
    {
        System.out.println(name);
    }

}
```

**分析**

> 代码运行，会先启动一个虚拟机进程，将AppMain.java类信息加载入方法区（内部类在使用时加载），方法区存储类的变量名、方法的具体实现。
>
> 当前代码只有一个线程，在运行时，线程被创建，系统自动划分堆作为公共空间，每个线程有私有的栈、程序计数器和本地方法栈。
>
> main方法入栈，后续方法执行也会入栈。
>
> 在执行方法中的代码，加载Sample类进方法区。在创建对象时，对象引用放在栈中，变量值会存放在堆中，对象具体信息会放在堆中，方法区会存储常量和静态变量、类的所有方法和类变量名。
>
> 在调用方法时，会根据栈引用找到堆中对象，然后找到方法区中具体方法进行执行。





## 垃圾回收

### 什么是垃圾？

- **引用计数法**：计数值为 0 的对象就是不可能再被使用的。**无法避免对象相互引用情况。**
  - 引用计数算法（Reachability Counting）是通过在对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。如果该对象被其它对象引用，则它的引用计数加1，如果删除对该对象的引用，那么它的引用计数就减1，当该对象的引用计数为0时，那么该对象就会被回收。
- **可达性分析法**（根搜索算法）：从根节点寻找引用节点，最后那些未被引用的节点会回收。
  - 通过一些被称为**引用链（GC Roots）**的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。
  - 哪些属于引用链？
    - 虚拟机栈中引用的对象
    - 方法去中类静态属性引用的对象
    - 方法去中敞亮引用的对象
    - 本地方法栈中JNI（一般说的Native方法）引用的对象



#### **四种引用**

引用分为**强引用、软引用，弱引用和虚引用**。

**如何区分**

> Java中默认声明的就是强引用
>
> 软引用是用来描述一些非必需但仍有用的对象。在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。
>
> 弱引用的引用强度比软引用要更弱一些。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。
>
> 虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。



**引用队列（ReferenceQueue）**

引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。

与软引用、弱引用不同，虚引用必须和引用队列一起使用。



**回收场景**

> 只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。哪怕内存不足时，JVM也会直接抛出OutOfMemoryError。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了
>
> 在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。
>
> 被软引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被软引用关联的对象。
>
> 被虚引用关联的对象，和其对象生存时间完全没关系，用于辅助监控对象是否存活，常用于对象销毁前的资源释放作用。





### 如何回收垃圾？

- **标记清除算法**：清理被标记的可回收对象。（容易产生不连续内存碎片）
- **复制算法**：将活着的对象复制到另一个地址中，清理原来的所有内存。（存活对象越多，复制效率越低，大量占用内存）
- **标记整理算法**：将存活对象移到一端，清理端边界以外的内存。（内存地址变动频繁，效率低）
- **分代回收算法**：根据存活时间分代，使其分代回收



#### **分代回收算法**

(大部分 `JVM` 的垃圾收集器采用的算法)

![分代内存分布](https://pics0.baidu.com/feed/c8ea15ce36d3d5394a5f0edfc4fdc555342ab0c8.jpeg?token=d2dbbd6e9a20079b15ff047303a89c13&s=3402553385BA44225A7514DE0200C031)

- **年轻代：刚new的对象**（复制算法）

  > 年轻代又分为Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 2个区。（设置两个 Survivor 区最大的好处就是解决内存碎片化。）
  >
  > IBM 公司的专业研究表明，有将近98%的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。
  >
  > 通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。
  >
  > Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。

- **老年代：多次回收仍存活的对象，大对象**（标记整理算法）

  > 虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加1岁。当年龄增加到15岁时，这时候就会被转移到老年代。当然，这里的15，JVM 也支持进行特殊设置。
  >
  > 虚拟机并不重视要求对象年龄必须到15岁，才会放入老年区，如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等你“成年”。
  >
  > 这其实有点类似于负载均衡，轮询是负载均衡的一种，保证每台机器都分得同样的请求。看似很均衡，但每台机的硬件不通，健康状况不同，我们还可以基于每台机接受的请求数，或每台机的响应时间等，来调整我们的负载均衡算法。

- 持久代：静态文件（基本不回收）



#### J**VM的垃圾回收器（GC）**（单线程和多线程）

新生代收集器使用的收集器：`Serial`、`Parallel New`、`Parallel Scavenge`。
老年代收集器使用的收集器：`Serial Old`、`Parallel Old`、`CMS`。



- Serial New收集器是针对新生代的收集器，采用的是复制算法
- Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理

- Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法
- Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理
- Parallel Old（并行）收集器，针对老年代，标记整理

- CMS收集器，基于标记清理
- G1收集器：整体上是基于标记 整理 ，局部采用复制





