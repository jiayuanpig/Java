# 面向对象

**核心概念：抽象、封装、继承和多态**



## 基本概念

- **抽象**：提取一类对象的公共特征【表现为类的属性和方法】
- **封装**：把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口【表现为属性private，Set/Get方法public】
  - 目的是尽量消除外部影响，保持内部稳定，减少程序耦合
- **继承**：继承已有类，创建新类【表现为子类可以继承父类的属性和方法，同时已有自己的属性和方法】
  - 父类的构造器不能够被继承
- **多态**：编译期多态：方法重载；运行时多态：因继承产生的方法重写，以及子类和父类的上下转型



### 重写（Override）和重载（Overload）

前提：方法名都一样

**【重载】和继承没有关系**

​	重载的条件：只看传参，要求传参类型不一样或者传参个数不一样（跟返回值无关）

**【重写】发生在继承关系中**

​	重写的条件：要求和父类的参数类型和方法返回值完全一致



如何看多态指向的内容？

- 子类没有覆盖重写就是父，子类如果覆盖重写就是子
- 成员变量：编译看左，运行看左
- 成员方法：编译看左，运行看右



### 接口（Interface）和抽象类（Abstract Class）

**本质区别**：二者的作用不一样，接口是对不同对象同一系列行为的抽取，抽象类是对相关对象同一系列行为和属性的抽取

**继承区别**：一个类可以实现多个接口，但是只能继承一个抽象类

**内容区别**：方法、变量的区别

【抽象类】：抽象类中和普通类一样，可以存放成员变量和普通的成员方法，如果一个类中含有抽象方法，就必须定义为抽象类

- 抽象类中可以没有抽象方法
- 抽象类中的抽象方法必须为public或protected（否则子类无法继承就不能实现抽象类了）

【接口】：**接口中只能定义常量（修饰符为public static final），方法只能是抽象方法（修饰符为public abstract）**



### 修饰符

**权限修饰符**

`public > protected > (default) > private`

与之对应：所有类--同包及子类--同包--自己

**类型修饰符**

final、static、abstract



### 类、实例化、对象

- 类：是事物的概括，包括属性和方法和构造器。
- 对象：类的具体表现，比如类中定义了属性名，对象赋予了属性值
- 实例化：一般情况下等同于创建对象。当发生对象的**上下转型时、接口实现时**会有所区别。



### 内部类

**内部类**包括：成员内部类（类里面）、局部内部类（方法里面）

​	**局部内部类**包括：一般局部内部类和匿名内部类

​	内部类的作用：可以封装操作；内部类对象可以访问外部类的内容，包括私有变量；可以实现同名方法调用

**注意：一个类文件中只能有一个public修饰的类**



### this和super

- this.成员变量：通过谁调用方法，谁就是this的对象
- super.成员变量：父类的成员变量

小技巧：将方法的返回值设为this可以实现方法链式调用。



## 上下转型

**向上转型**：子类转为父类；向下转型：父类再次变为子类

**转型的意义：**

向上转型的作用：当有多种子类时，可以向上转型调用一个方法，提高了代码的可扩展性。向下转型的作用：为了重新获取向上转型丢失的方法。



## 创建对象的方式（四种）

1. new关键字：创建对象常用的方法
2. 反射
3. 克隆（Clone）
4. 序列化



## 继承时的调用过程

总结：

1. 第一部分执行的是父类的静态代码块—子类的静态代码块—主程序。
   - 这一部分都是**执行一次**，与建立多少对象没有关系。
2. 第二部分new了一个子类的对象，并调用了方法。
   - 执行顺序为**父类的非静态代码块—父类的无参构造函数，然后是子类的非静态代码块—子类构造函数—子类的方法。**

测试代码：

```java
//父类
public class FatherTest {
    private String name;
    FatherTest(){
       System.out.println("--父类的无参构造函数--");
    }
    FatherTest(String name){
       this.name=name;
       System.out.println("--父类的有参构造函数--"+this.name);
    }
    static{
       System.out.println("--父类的静态代码块--");
    }
    {
       System.out.println("--父类的非静态代码块--");
    }

    public void speak(){
       System.out.println("--父类的方法--");
    }
    
    public static void main(String[] args) {
       System.out.println("--父类主程序--");
       FatherTest father=new FatherTest("父亲的名字");
       father.speak();    
 	}
    //结果输出
    /*
    --父类的静态代码块--
	--父类主程序--
	--父类的非静态代码块--
	--父类的有参构造函数--父亲的名字
	--父类的方法—    
    */
}

//子类
public class SonTest extends FatherTest {

    private String name;
    static{
       System.out.println("--子类的静态代码块--");
    }
    {
       System.out.println("--子类的非静态代码块--");
    }

    SonTest(){
       System.out.println("--子类的无参构造函数--");
    }   
    SonTest(String name){
       this.name=name;
       System.out.println("--子类的有参构造函数--"+this.name);
    }

    @Override
    public void speak(){
       System.out.println("--子类Override了父类的方法--");
    }
    
    public static void main(String[] args) {
       System.out.println("--子类主程序--");
       FatherTest father=new FatherTest("父亲的名字");
       father.speak();
       SonTest son=new SonTest("儿子的名字");
       son.speak();
	}
    //结果输出
    /*
    --父类的静态代码块--
    --子类的静态代码块--
    --子类主程序--
    --父类的非静态代码块--
    --父类的有参构造函数--父亲的名字
    --父类的方法--
    --父类的非静态代码块--
    --父类的无参构造函数--
    --子类的非静态代码块--
    --子类的有参构造函数--儿子的名字
    --子类Override了父类的方法--
    */
}


```

